{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 70, "column": 0}, "map": {"version":3,"sources":["file:///home/alabrador/dashboard-ansible-ia/src/lib/auth/local-user-store.ts"],"sourcesContent":["import { randomBytes, scrypt as scryptCallback, timingSafeEqual } from \"node:crypto\";\nimport { promises as fs } from \"node:fs\";\nimport { join } from \"node:path\";\nimport { promisify } from \"node:util\";\nimport { kv } from \"@vercel/kv\";\n\nconst scrypt = promisify(scryptCallback);\nconst STORE_DIR = join(process.cwd(), \"uploads\");\nconst STORE_PATH = join(STORE_DIR, \"local-users.json\");\nconst KV_USERS_KEY = \"dashboard:local-users\";\n\ntype StoredLocalUser = {\n  email: string;\n  passwordHash: string;\n  salt: string;\n};\n\ntype StoredLocalUserFile = {\n  users: StoredLocalUser[];\n};\n\nfunction isVercelKvConfigured(): boolean {\n  return Boolean(process.env.KV_REST_API_URL && process.env.KV_REST_API_TOKEN);\n}\n\nasync function readStoreFromKv(): Promise<StoredLocalUserFile> {\n  const payload = await kv.get<StoredLocalUserFile>(KV_USERS_KEY);\n\n  if (!payload || !Array.isArray(payload.users)) {\n    return { users: [] };\n  }\n\n  return {\n    users: payload.users.filter(\n      (item) =>\n        typeof item?.email === \"string\" &&\n        typeof item?.passwordHash === \"string\" &&\n        typeof item?.salt === \"string\",\n    ),\n  };\n}\n\nasync function writeStoreToKv(data: StoredLocalUserFile): Promise<void> {\n  await kv.set(KV_USERS_KEY, data);\n}\n\nasync function ensureStoreFile(): Promise<void> {\n  await fs.mkdir(STORE_DIR, { recursive: true });\n\n  try {\n    await fs.access(STORE_PATH);\n  } catch {\n    const initialData: StoredLocalUserFile = { users: [] };\n    await fs.writeFile(STORE_PATH, JSON.stringify(initialData, null, 2), \"utf8\");\n  }\n}\n\nasync function readStore(): Promise<StoredLocalUserFile> {\n  if (isVercelKvConfigured()) {\n    return readStoreFromKv();\n  }\n\n  await ensureStoreFile();\n  const raw = await fs.readFile(STORE_PATH, \"utf8\");\n\n  try {\n    const parsed = JSON.parse(raw) as StoredLocalUserFile;\n    if (!parsed || !Array.isArray(parsed.users)) {\n      return { users: [] };\n    }\n\n    return {\n      users: parsed.users.filter(\n        (item) =>\n          typeof item?.email === \"string\" &&\n          typeof item?.passwordHash === \"string\" &&\n          typeof item?.salt === \"string\",\n      ),\n    };\n  } catch {\n    return { users: [] };\n  }\n}\n\nasync function writeStore(data: StoredLocalUserFile): Promise<void> {\n  if (isVercelKvConfigured()) {\n    await writeStoreToKv(data);\n    return;\n  }\n\n  await ensureStoreFile();\n  await fs.writeFile(STORE_PATH, JSON.stringify(data, null, 2), \"utf8\");\n}\n\nasync function hashPassword(password: string, salt: string): Promise<string> {\n  const derivedKey = (await scrypt(password, salt, 64)) as Buffer;\n  return derivedKey.toString(\"hex\");\n}\n\nexport async function listStoredLocalUserEmails(): Promise<string[]> {\n  const store = await readStore();\n  return store.users.map((user) => user.email).sort((a, b) => a.localeCompare(b));\n}\n\nexport async function upsertStoredLocalUser(email: string, password: string): Promise<void> {\n  const normalizedEmail = email.trim().toLowerCase();\n  const salt = randomBytes(16).toString(\"hex\");\n  const passwordHash = await hashPassword(password, salt);\n\n  const store = await readStore();\n  const nextUsers = store.users.filter((user) => user.email !== normalizedEmail);\n  nextUsers.push({ email: normalizedEmail, passwordHash, salt });\n\n  await writeStore({ users: nextUsers });\n}\n\nexport async function removeStoredLocalUser(email: string): Promise<boolean> {\n  const normalizedEmail = email.trim().toLowerCase();\n  const store = await readStore();\n  const nextUsers = store.users.filter((user) => user.email !== normalizedEmail);\n\n  if (nextUsers.length === store.users.length) {\n    return false;\n  }\n\n  await writeStore({ users: nextUsers });\n  return true;\n}\n\nexport async function verifyStoredLocalUser(email: string, password: string): Promise<boolean> {\n  const normalizedEmail = email.trim().toLowerCase();\n  const store = await readStore();\n  const user = store.users.find((item) => item.email === normalizedEmail);\n\n  if (!user) {\n    return false;\n  }\n\n  const providedHash = await hashPassword(password, user.salt);\n  const expected = Buffer.from(user.passwordHash, \"hex\");\n  const actual = Buffer.from(providedHash, \"hex\");\n\n  if (expected.length !== actual.length) {\n    return false;\n  }\n\n  return timingSafeEqual(expected, actual);\n}"],"names":[],"mappings":"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"}},
    {"offset": {"line": 208, "column": 0}, "map": {"version":3,"sources":["file:///home/alabrador/dashboard-ansible-ia/src/app/api/auth/local-users/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\nimport {\n  listStoredLocalUserEmails,\n  removeStoredLocalUser,\n  upsertStoredLocalUser,\n} from \"@/lib/auth/local-user-store\";\n\ntype LocalUserBody = {\n  email?: string;\n  password?: string;\n};\n\nfunction normalizeEmail(email: string): string {\n  return email.trim().toLowerCase();\n}\n\nfunction isValidEmail(email: string): boolean {\n  return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(email);\n}\n\nexport async function GET() {\n  try {\n    const users = await listStoredLocalUserEmails();\n    return NextResponse.json({ users });\n  } catch {\n    return NextResponse.json(\n      { error: \"No se pudo cargar la lista de usuarios locales.\" },\n      { status: 500 },\n    );\n  }\n}\n\nexport async function POST(request: Request) {\n  try {\n    const body = (await request.json()) as LocalUserBody;\n    const email = normalizeEmail(body.email ?? \"\");\n    const password = body.password?.trim() ?? \"\";\n\n    if (!email || !password) {\n      return NextResponse.json(\n        { error: \"Debes enviar correo y contraseña.\" },\n        { status: 400 },\n      );\n    }\n\n    if (!isValidEmail(email)) {\n      return NextResponse.json(\n        { error: \"El correo no tiene formato válido.\" },\n        { status: 400 },\n      );\n    }\n\n    if (password.length < 8) {\n      return NextResponse.json(\n        { error: \"La contraseña debe tener al menos 8 caracteres.\" },\n        { status: 400 },\n      );\n    }\n\n    await upsertStoredLocalUser(email, password);\n    return NextResponse.json({ ok: true });\n  } catch {\n    return NextResponse.json(\n      { error: \"No se pudo guardar el usuario local.\" },\n      { status: 500 },\n    );\n  }\n}\n\nexport async function DELETE(request: Request) {\n  try {\n    const body = (await request.json()) as LocalUserBody;\n    const email = normalizeEmail(body.email ?? \"\");\n\n    if (!email) {\n      return NextResponse.json(\n        { error: \"Debes indicar el correo a eliminar.\" },\n        { status: 400 },\n      );\n    }\n\n    const removed = await removeStoredLocalUser(email);\n    if (!removed) {\n      return NextResponse.json(\n        { error: \"Usuario no encontrado.\" },\n        { status: 404 },\n      );\n    }\n\n    return NextResponse.json({ ok: true });\n  } catch {\n    return NextResponse.json(\n      { error: \"No se pudo eliminar el usuario local.\" },\n      { status: 500 },\n    );\n  }\n}"],"names":[],"mappings":";;;;;;;;AAAA;AACA;;;AAWA,SAAS,eAAe,KAAa;IACnC,OAAO,MAAM,IAAI,GAAG,WAAW;AACjC;AAEA,SAAS,aAAa,KAAa;IACjC,OAAO,6BAA6B,IAAI,CAAC;AAC3C;AAEO,eAAe;IACpB,IAAI;QACF,MAAM,QAAQ,MAAM,IAAA,2KAAyB;QAC7C,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE;QAAM;IACnC,EAAE,OAAM;QACN,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAkD,GAC3D;YAAE,QAAQ;QAAI;IAElB;AACF;AAEO,eAAe,KAAK,OAAgB;IACzC,IAAI;QACF,MAAM,OAAQ,MAAM,QAAQ,IAAI;QAChC,MAAM,QAAQ,eAAe,KAAK,KAAK,IAAI;QAC3C,MAAM,WAAW,KAAK,QAAQ,EAAE,UAAU;QAE1C,IAAI,CAAC,SAAS,CAAC,UAAU;YACvB,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAoC,GAC7C;gBAAE,QAAQ;YAAI;QAElB;QAEA,IAAI,CAAC,aAAa,QAAQ;YACxB,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAqC,GAC9C;gBAAE,QAAQ;YAAI;QAElB;QAEA,IAAI,SAAS,MAAM,GAAG,GAAG;YACvB,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAkD,GAC3D;gBAAE,QAAQ;YAAI;QAElB;QAEA,MAAM,IAAA,uKAAqB,EAAC,OAAO;QACnC,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,IAAI;QAAK;IACtC,EAAE,OAAM;QACN,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAuC,GAChD;YAAE,QAAQ;QAAI;IAElB;AACF;AAEO,eAAe,OAAO,OAAgB;IAC3C,IAAI;QACF,MAAM,OAAQ,MAAM,QAAQ,IAAI;QAChC,MAAM,QAAQ,eAAe,KAAK,KAAK,IAAI;QAE3C,IAAI,CAAC,OAAO;YACV,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAsC,GAC/C;gBAAE,QAAQ;YAAI;QAElB;QAEA,MAAM,UAAU,MAAM,IAAA,uKAAqB,EAAC;QAC5C,IAAI,CAAC,SAAS;YACZ,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAyB,GAClC;gBAAE,QAAQ;YAAI;QAElB;QAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,IAAI;QAAK;IACtC,EAAE,OAAM;QACN,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAwC,GACjD;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}