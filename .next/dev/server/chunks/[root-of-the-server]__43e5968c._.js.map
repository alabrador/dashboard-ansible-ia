{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 70, "column": 0}, "map": {"version":3,"sources":["file:///home/alabrador/dashboard-ansible-ia/src/lib/auth/local-user-store.ts"],"sourcesContent":["import { randomBytes, scrypt as scryptCallback, timingSafeEqual } from \"node:crypto\";\nimport { promises as fs } from \"node:fs\";\nimport { join } from \"node:path\";\nimport { promisify } from \"node:util\";\nimport { kv } from \"@vercel/kv\";\nimport type { UserRole } from \"@/lib/auth/types\";\n\nconst scrypt = promisify(scryptCallback);\nconst STORE_DIR = join(process.cwd(), \"uploads\");\nconst STORE_PATH = join(STORE_DIR, \"local-users.json\");\nconst KV_USERS_KEY = \"dashboard:local-users\";\n\ntype StoredLocalUser = {\n  email: string;\n  username: string;\n  firstName: string;\n  lastName: string;\n  role: UserRole;\n  passwordHash: string;\n  salt: string;\n};\n\nexport type LocalUserProfile = {\n  email: string;\n  username: string;\n  firstName: string;\n  lastName: string;\n  role: UserRole;\n};\n\ntype StoredLocalUserFile = {\n  users: StoredLocalUser[];\n};\n\ntype LegacyStoredLocalUser = {\n  email?: string;\n  passwordHash?: string;\n  salt?: string;\n  username?: string;\n  firstName?: string;\n  lastName?: string;\n  role?: UserRole;\n};\n\nfunction normalizeEmail(email: string): string {\n  return email.trim().toLowerCase();\n}\n\nfunction normalizeUsername(username: string): string {\n  return username.trim().toLowerCase();\n}\n\nfunction normalizeName(value: string): string {\n  return value.trim().replace(/\\s+/g, \" \");\n}\n\nfunction usernameFromEmail(email: string): string {\n  const localPart = normalizeEmail(email).split(\"@\")[0] ?? \"\";\n  return normalizeUsername(localPart || \"usuario\");\n}\n\nfunction normalizeRole(role: unknown): UserRole {\n  return role === \"tecnico\" ? \"tecnico\" : \"administrativo\";\n}\n\nfunction normalizeStoredUser(item: LegacyStoredLocalUser): StoredLocalUser | null {\n  if (\n    typeof item?.email !== \"string\" ||\n    typeof item?.passwordHash !== \"string\" ||\n    typeof item?.salt !== \"string\"\n  ) {\n    return null;\n  }\n\n  const email = normalizeEmail(item.email);\n  if (!email) {\n    return null;\n  }\n\n  const username =\n    typeof item.username === \"string\" && item.username.trim()\n      ? normalizeUsername(item.username)\n      : usernameFromEmail(email);\n\n  const firstName = typeof item.firstName === \"string\" ? normalizeName(item.firstName) : \"\";\n  const lastName = typeof item.lastName === \"string\" ? normalizeName(item.lastName) : \"\";\n  const role = normalizeRole(item.role);\n\n  return {\n    email,\n    username,\n    firstName,\n    lastName,\n    role,\n    passwordHash: item.passwordHash,\n    salt: item.salt,\n  };\n}\n\nfunction sortUsers(users: StoredLocalUser[]): StoredLocalUser[] {\n  return [...users].sort((a, b) => a.username.localeCompare(b.username) || a.email.localeCompare(b.email));\n}\n\nfunction isVercelKvConfigured(): boolean {\n  return Boolean(process.env.KV_REST_API_URL && process.env.KV_REST_API_TOKEN);\n}\n\nasync function readStoreFromKv(): Promise<StoredLocalUserFile> {\n  const payload = await kv.get<StoredLocalUserFile>(KV_USERS_KEY);\n\n  if (!payload || !Array.isArray(payload.users)) {\n    return { users: [] };\n  }\n\n  return {\n    users: payload.users\n      .map((item) => normalizeStoredUser(item as LegacyStoredLocalUser))\n      .filter((item): item is StoredLocalUser => item !== null),\n  };\n}\n\nasync function writeStoreToKv(data: StoredLocalUserFile): Promise<void> {\n  await kv.set(KV_USERS_KEY, data);\n}\n\nasync function ensureStoreFile(): Promise<void> {\n  await fs.mkdir(STORE_DIR, { recursive: true });\n\n  try {\n    await fs.access(STORE_PATH);\n  } catch {\n    const initialData: StoredLocalUserFile = { users: [] };\n    await fs.writeFile(STORE_PATH, JSON.stringify(initialData, null, 2), \"utf8\");\n  }\n}\n\nasync function readStore(): Promise<StoredLocalUserFile> {\n  if (isVercelKvConfigured()) {\n    return readStoreFromKv();\n  }\n\n  await ensureStoreFile();\n  const raw = await fs.readFile(STORE_PATH, \"utf8\");\n\n  try {\n    const parsed = JSON.parse(raw) as StoredLocalUserFile;\n    if (!parsed || !Array.isArray(parsed.users)) {\n      return { users: [] };\n    }\n\n    return {\n      users: parsed.users\n        .map((item) => normalizeStoredUser(item as LegacyStoredLocalUser))\n        .filter((item): item is StoredLocalUser => item !== null),\n    };\n  } catch {\n    return { users: [] };\n  }\n}\n\nasync function writeStore(data: StoredLocalUserFile): Promise<void> {\n  if (isVercelKvConfigured()) {\n    await writeStoreToKv(data);\n    return;\n  }\n\n  await ensureStoreFile();\n  await fs.writeFile(STORE_PATH, JSON.stringify(data, null, 2), \"utf8\");\n}\n\nasync function hashPassword(password: string, salt: string): Promise<string> {\n  const derivedKey = (await scrypt(password, salt, 64)) as Buffer;\n  return derivedKey.toString(\"hex\");\n}\n\nexport async function listStoredLocalUserEmails(): Promise<string[]> {\n  const store = await readStore();\n  return sortUsers(store.users).map((user) => user.email);\n}\n\nexport async function listStoredLocalUsers(): Promise<LocalUserProfile[]> {\n  const store = await readStore();\n  return sortUsers(store.users).map((user) => ({\n    email: user.email,\n    username: user.username,\n    firstName: user.firstName,\n    lastName: user.lastName,\n    role: user.role,\n  }));\n}\n\nexport async function upsertStoredLocalUser(\n  profile: LocalUserProfile,\n  password?: string,\n  previousIdentifier?: string,\n): Promise<void> {\n  const normalizedEmail = normalizeEmail(profile.email);\n  const normalizedUsername = normalizeUsername(profile.username);\n  const normalizedFirstName = normalizeName(profile.firstName);\n  const normalizedLastName = normalizeName(profile.lastName);\n  const normalizedRole = normalizeRole(profile.role);\n  const normalizedPreviousIdentifier = previousIdentifier?.trim().toLowerCase() ?? \"\";\n\n  const store = await readStore();\n  const existingUser = store.users.find(\n    (user) => user.email === normalizedEmail || user.username === normalizedUsername,\n  );\n\n  let salt = existingUser?.salt;\n  let passwordHash = existingUser?.passwordHash;\n\n  if (password && password.trim()) {\n    salt = randomBytes(16).toString(\"hex\");\n    passwordHash = await hashPassword(password, salt);\n  }\n\n  if (!salt || !passwordHash) {\n    throw new Error(\"Password is required for new local users.\");\n  }\n\n  const nextUsers = store.users.filter(\n    (user) =>\n      user.email !== normalizedEmail &&\n      user.username !== normalizedUsername &&\n      user.email !== normalizedPreviousIdentifier &&\n      user.username !== normalizedPreviousIdentifier,\n  );\n\n  nextUsers.push({\n    email: normalizedEmail,\n    username: normalizedUsername,\n    firstName: normalizedFirstName,\n    lastName: normalizedLastName,\n    role: normalizedRole,\n    passwordHash,\n    salt,\n  });\n\n  await writeStore({ users: sortUsers(nextUsers) });\n}\n\nexport async function removeStoredLocalUser(identifier: string): Promise<boolean> {\n  const normalizedIdentifier = identifier.trim().toLowerCase();\n  const store = await readStore();\n  const nextUsers = store.users.filter(\n    (user) => user.email !== normalizedIdentifier && user.username !== normalizedIdentifier,\n  );\n\n  if (nextUsers.length === store.users.length) {\n    return false;\n  }\n\n  await writeStore({ users: sortUsers(nextUsers) });\n  return true;\n}\n\nexport async function verifyStoredLocalUser(\n  identifier: string,\n  password: string,\n): Promise<LocalUserProfile | null> {\n  const normalizedIdentifier = identifier.trim().toLowerCase();\n  const store = await readStore();\n  const user = store.users.find(\n    (item) => item.email === normalizedIdentifier || item.username === normalizedIdentifier,\n  );\n\n  if (!user) {\n    return null;\n  }\n\n  const providedHash = await hashPassword(password, user.salt);\n  const expected = Buffer.from(user.passwordHash, \"hex\");\n  const actual = Buffer.from(providedHash, \"hex\");\n\n  if (expected.length !== actual.length) {\n    return null;\n  }\n\n  if (!timingSafeEqual(expected, actual)) {\n    return null;\n  }\n\n  return {\n    email: user.email,\n    username: user.username,\n    firstName: user.firstName,\n    lastName: user.lastName,\n    role: user.role,\n  };\n}"],"names":[],"mappings":";;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAGA,MAAM,SAAS,IAAA,8HAAS,EAAC,+HAAc;AACvC,MAAM,YAAY,IAAA,yHAAI,EAAC,QAAQ,GAAG,IAAI;AACtC,MAAM,aAAa,IAAA,yHAAI,EAAC,WAAW;AACnC,MAAM,eAAe;AAkCrB,SAAS,eAAe,KAAa;IACnC,OAAO,MAAM,IAAI,GAAG,WAAW;AACjC;AAEA,SAAS,kBAAkB,QAAgB;IACzC,OAAO,SAAS,IAAI,GAAG,WAAW;AACpC;AAEA,SAAS,cAAc,KAAa;IAClC,OAAO,MAAM,IAAI,GAAG,OAAO,CAAC,QAAQ;AACtC;AAEA,SAAS,kBAAkB,KAAa;IACtC,MAAM,YAAY,eAAe,OAAO,KAAK,CAAC,IAAI,CAAC,EAAE,IAAI;IACzD,OAAO,kBAAkB,aAAa;AACxC;AAEA,SAAS,cAAc,IAAa;IAClC,OAAO,SAAS,YAAY,YAAY;AAC1C;AAEA,SAAS,oBAAoB,IAA2B;IACtD,IACE,OAAO,MAAM,UAAU,YACvB,OAAO,MAAM,iBAAiB,YAC9B,OAAO,MAAM,SAAS,UACtB;QACA,OAAO;IACT;IAEA,MAAM,QAAQ,eAAe,KAAK,KAAK;IACvC,IAAI,CAAC,OAAO;QACV,OAAO;IACT;IAEA,MAAM,WACJ,OAAO,KAAK,QAAQ,KAAK,YAAY,KAAK,QAAQ,CAAC,IAAI,KACnD,kBAAkB,KAAK,QAAQ,IAC/B,kBAAkB;IAExB,MAAM,YAAY,OAAO,KAAK,SAAS,KAAK,WAAW,cAAc,KAAK,SAAS,IAAI;IACvF,MAAM,WAAW,OAAO,KAAK,QAAQ,KAAK,WAAW,cAAc,KAAK,QAAQ,IAAI;IACpF,MAAM,OAAO,cAAc,KAAK,IAAI;IAEpC,OAAO;QACL;QACA;QACA;QACA;QACA;QACA,cAAc,KAAK,YAAY;QAC/B,MAAM,KAAK,IAAI;IACjB;AACF;AAEA,SAAS,UAAU,KAAwB;IACzC,OAAO;WAAI;KAAM,CAAC,IAAI,CAAC,CAAC,GAAG,IAAM,EAAE,QAAQ,CAAC,aAAa,CAAC,EAAE,QAAQ,KAAK,EAAE,KAAK,CAAC,aAAa,CAAC,EAAE,KAAK;AACxG;AAEA,SAAS;IACP,OAAO,QAAQ,QAAQ,GAAG,CAAC,eAAe,IAAI,QAAQ,GAAG,CAAC,iBAAiB;AAC7E;AAEA,eAAe;IACb,MAAM,UAAU,MAAM,uJAAE,CAAC,GAAG,CAAsB;IAElD,IAAI,CAAC,WAAW,CAAC,MAAM,OAAO,CAAC,QAAQ,KAAK,GAAG;QAC7C,OAAO;YAAE,OAAO,EAAE;QAAC;IACrB;IAEA,OAAO;QACL,OAAO,QAAQ,KAAK,CACjB,GAAG,CAAC,CAAC,OAAS,oBAAoB,OAClC,MAAM,CAAC,CAAC,OAAkC,SAAS;IACxD;AACF;AAEA,eAAe,eAAe,IAAyB;IACrD,MAAM,uJAAE,CAAC,GAAG,CAAC,cAAc;AAC7B;AAEA,eAAe;IACb,MAAM,yHAAE,CAAC,KAAK,CAAC,WAAW;QAAE,WAAW;IAAK;IAE5C,IAAI;QACF,MAAM,yHAAE,CAAC,MAAM,CAAC;IAClB,EAAE,OAAM;QACN,MAAM,cAAmC;YAAE,OAAO,EAAE;QAAC;QACrD,MAAM,yHAAE,CAAC,SAAS,CAAC,YAAY,KAAK,SAAS,CAAC,aAAa,MAAM,IAAI;IACvE;AACF;AAEA,eAAe;IACb,IAAI,wBAAwB;QAC1B,OAAO;IACT;IAEA,MAAM;IACN,MAAM,MAAM,MAAM,yHAAE,CAAC,QAAQ,CAAC,YAAY;IAE1C,IAAI;QACF,MAAM,SAAS,KAAK,KAAK,CAAC;QAC1B,IAAI,CAAC,UAAU,CAAC,MAAM,OAAO,CAAC,OAAO,KAAK,GAAG;YAC3C,OAAO;gBAAE,OAAO,EAAE;YAAC;QACrB;QAEA,OAAO;YACL,OAAO,OAAO,KAAK,CAChB,GAAG,CAAC,CAAC,OAAS,oBAAoB,OAClC,MAAM,CAAC,CAAC,OAAkC,SAAS;QACxD;IACF,EAAE,OAAM;QACN,OAAO;YAAE,OAAO,EAAE;QAAC;IACrB;AACF;AAEA,eAAe,WAAW,IAAyB;IACjD,IAAI,wBAAwB;QAC1B,MAAM,eAAe;QACrB;IACF;IAEA,MAAM;IACN,MAAM,yHAAE,CAAC,SAAS,CAAC,YAAY,KAAK,SAAS,CAAC,MAAM,MAAM,IAAI;AAChE;AAEA,eAAe,aAAa,QAAgB,EAAE,IAAY;IACxD,MAAM,aAAc,MAAM,OAAO,UAAU,MAAM;IACjD,OAAO,WAAW,QAAQ,CAAC;AAC7B;AAEO,eAAe;IACpB,MAAM,QAAQ,MAAM;IACpB,OAAO,UAAU,MAAM,KAAK,EAAE,GAAG,CAAC,CAAC,OAAS,KAAK,KAAK;AACxD;AAEO,eAAe;IACpB,MAAM,QAAQ,MAAM;IACpB,OAAO,UAAU,MAAM,KAAK,EAAE,GAAG,CAAC,CAAC,OAAS,CAAC;YAC3C,OAAO,KAAK,KAAK;YACjB,UAAU,KAAK,QAAQ;YACvB,WAAW,KAAK,SAAS;YACzB,UAAU,KAAK,QAAQ;YACvB,MAAM,KAAK,IAAI;QACjB,CAAC;AACH;AAEO,eAAe,sBACpB,OAAyB,EACzB,QAAiB,EACjB,kBAA2B;IAE3B,MAAM,kBAAkB,eAAe,QAAQ,KAAK;IACpD,MAAM,qBAAqB,kBAAkB,QAAQ,QAAQ;IAC7D,MAAM,sBAAsB,cAAc,QAAQ,SAAS;IAC3D,MAAM,qBAAqB,cAAc,QAAQ,QAAQ;IACzD,MAAM,iBAAiB,cAAc,QAAQ,IAAI;IACjD,MAAM,+BAA+B,oBAAoB,OAAO,iBAAiB;IAEjF,MAAM,QAAQ,MAAM;IACpB,MAAM,eAAe,MAAM,KAAK,CAAC,IAAI,CACnC,CAAC,OAAS,KAAK,KAAK,KAAK,mBAAmB,KAAK,QAAQ,KAAK;IAGhE,IAAI,OAAO,cAAc;IACzB,IAAI,eAAe,cAAc;IAEjC,IAAI,YAAY,SAAS,IAAI,IAAI;QAC/B,OAAO,IAAA,oIAAW,EAAC,IAAI,QAAQ,CAAC;QAChC,eAAe,MAAM,aAAa,UAAU;IAC9C;IAEA,IAAI,CAAC,QAAQ,CAAC,cAAc;QAC1B,MAAM,IAAI,MAAM;IAClB;IAEA,MAAM,YAAY,MAAM,KAAK,CAAC,MAAM,CAClC,CAAC,OACC,KAAK,KAAK,KAAK,mBACf,KAAK,QAAQ,KAAK,sBAClB,KAAK,KAAK,KAAK,gCACf,KAAK,QAAQ,KAAK;IAGtB,UAAU,IAAI,CAAC;QACb,OAAO;QACP,UAAU;QACV,WAAW;QACX,UAAU;QACV,MAAM;QACN;QACA;IACF;IAEA,MAAM,WAAW;QAAE,OAAO,UAAU;IAAW;AACjD;AAEO,eAAe,sBAAsB,UAAkB;IAC5D,MAAM,uBAAuB,WAAW,IAAI,GAAG,WAAW;IAC1D,MAAM,QAAQ,MAAM;IACpB,MAAM,YAAY,MAAM,KAAK,CAAC,MAAM,CAClC,CAAC,OAAS,KAAK,KAAK,KAAK,wBAAwB,KAAK,QAAQ,KAAK;IAGrE,IAAI,UAAU,MAAM,KAAK,MAAM,KAAK,CAAC,MAAM,EAAE;QAC3C,OAAO;IACT;IAEA,MAAM,WAAW;QAAE,OAAO,UAAU;IAAW;IAC/C,OAAO;AACT;AAEO,eAAe,sBACpB,UAAkB,EAClB,QAAgB;IAEhB,MAAM,uBAAuB,WAAW,IAAI,GAAG,WAAW;IAC1D,MAAM,QAAQ,MAAM;IACpB,MAAM,OAAO,MAAM,KAAK,CAAC,IAAI,CAC3B,CAAC,OAAS,KAAK,KAAK,KAAK,wBAAwB,KAAK,QAAQ,KAAK;IAGrE,IAAI,CAAC,MAAM;QACT,OAAO;IACT;IAEA,MAAM,eAAe,MAAM,aAAa,UAAU,KAAK,IAAI;IAC3D,MAAM,WAAW,OAAO,IAAI,CAAC,KAAK,YAAY,EAAE;IAChD,MAAM,SAAS,OAAO,IAAI,CAAC,cAAc;IAEzC,IAAI,SAAS,MAAM,KAAK,OAAO,MAAM,EAAE;QACrC,OAAO;IACT;IAEA,IAAI,CAAC,IAAA,wIAAe,EAAC,UAAU,SAAS;QACtC,OAAO;IACT;IAEA,OAAO;QACL,OAAO,KAAK,KAAK;QACjB,UAAU,KAAK,QAAQ;QACvB,WAAW,KAAK,SAAS;QACzB,UAAU,KAAK,QAAQ;QACvB,MAAM,KAAK,IAAI;IACjB;AACF"}},
    {"offset": {"line": 289, "column": 0}, "map": {"version":3,"sources":["file:///home/alabrador/dashboard-ansible-ia/src/lib/auth/local-auth.ts"],"sourcesContent":["import type { AuthResult, AuthUser } from \"@/lib/auth/types\";\nimport { verifyStoredLocalUser } from \"@/lib/auth/local-user-store\";\n\ntype LocalCredential = {\n  email: string;\n  username: string;\n  password: string;\n  role: \"administrativo\";\n};\n\nfunction parseLocalUsers(): LocalCredential[] {\n  const raw = process.env.LOCAL_AUTH_USERS ?? \"\";\n  if (!raw.trim()) {\n    return [];\n  }\n\n  return raw\n    .split(\";\")\n    .map((entry) => entry.trim())\n    .filter(Boolean)\n    .map((entry) => {\n      const separator = entry.indexOf(\":\");\n      if (separator <= 0) {\n        return null;\n      }\n\n      const loginValue = entry.slice(0, separator).trim().toLowerCase();\n      const password = entry.slice(separator + 1).trim();\n\n      if (!loginValue || !password) {\n        return null;\n      }\n\n      if (loginValue.includes(\"@\")) {\n        return {\n          email: loginValue,\n          username: loginValue.split(\"@\")[0] ?? \"\",\n          password,\n          role: \"administrativo\",\n        };\n      }\n\n      return {\n        email: `${loginValue}@local`,\n        username: loginValue,\n        password,\n        role: \"administrativo\",\n      };\n    })\n    .filter((item): item is LocalCredential => item !== null);\n}\n\nexport async function authenticateLocal(identifier: string, password: string): Promise<AuthResult> {\n  const normalizedIdentifier = identifier.trim().toLowerCase();\n  let storedUser = null;\n\n  try {\n    storedUser = await verifyStoredLocalUser(normalizedIdentifier, password);\n  } catch {\n    storedUser = null;\n  }\n\n  if (storedUser) {\n    const displayName = [storedUser.firstName, storedUser.lastName].filter(Boolean).join(\" \");\n\n    return {\n      ok: true,\n      user: {\n        email: storedUser.email,\n        username: storedUser.username,\n        firstName: storedUser.firstName,\n        lastName: storedUser.lastName,\n        displayName: displayName || storedUser.username,\n        role: storedUser.role,\n        source: \"local\",\n      },\n    };\n  }\n\n  {\n    const users = parseLocalUsers();\n    const localUser = users.find(\n      (user) => user.email === normalizedIdentifier || user.username === normalizedIdentifier,\n    );\n\n    if (!localUser || localUser.password !== password) {\n      return { ok: false, error: \"Credenciales locales inválidas.\" };\n    }\n\n    const user: AuthUser = {\n      email: localUser.email,\n      username: localUser.username,\n      displayName: localUser.username,\n      role: localUser.role,\n      source: \"local\",\n    };\n\n    return { ok: true, user };\n  }\n}"],"names":[],"mappings":";;;;AACA;;AASA,SAAS;IACP,MAAM,MAAM,QAAQ,GAAG,CAAC,gBAAgB,IAAI;IAC5C,IAAI,CAAC,IAAI,IAAI,IAAI;QACf,OAAO,EAAE;IACX;IAEA,OAAO,IACJ,KAAK,CAAC,KACN,GAAG,CAAC,CAAC,QAAU,MAAM,IAAI,IACzB,MAAM,CAAC,SACP,GAAG,CAAC,CAAC;QACJ,MAAM,YAAY,MAAM,OAAO,CAAC;QAChC,IAAI,aAAa,GAAG;YAClB,OAAO;QACT;QAEA,MAAM,aAAa,MAAM,KAAK,CAAC,GAAG,WAAW,IAAI,GAAG,WAAW;QAC/D,MAAM,WAAW,MAAM,KAAK,CAAC,YAAY,GAAG,IAAI;QAEhD,IAAI,CAAC,cAAc,CAAC,UAAU;YAC5B,OAAO;QACT;QAEA,IAAI,WAAW,QAAQ,CAAC,MAAM;YAC5B,OAAO;gBACL,OAAO;gBACP,UAAU,WAAW,KAAK,CAAC,IAAI,CAAC,EAAE,IAAI;gBACtC;gBACA,MAAM;YACR;QACF;QAEA,OAAO;YACL,OAAO,GAAG,WAAW,MAAM,CAAC;YAC5B,UAAU;YACV;YACA,MAAM;QACR;IACF,GACC,MAAM,CAAC,CAAC,OAAkC,SAAS;AACxD;AAEO,eAAe,kBAAkB,UAAkB,EAAE,QAAgB;IAC1E,MAAM,uBAAuB,WAAW,IAAI,GAAG,WAAW;IAC1D,IAAI,aAAa;IAEjB,IAAI;QACF,aAAa,MAAM,IAAA,uKAAqB,EAAC,sBAAsB;IACjE,EAAE,OAAM;QACN,aAAa;IACf;IAEA,IAAI,YAAY;QACd,MAAM,cAAc;YAAC,WAAW,SAAS;YAAE,WAAW,QAAQ;SAAC,CAAC,MAAM,CAAC,SAAS,IAAI,CAAC;QAErF,OAAO;YACL,IAAI;YACJ,MAAM;gBACJ,OAAO,WAAW,KAAK;gBACvB,UAAU,WAAW,QAAQ;gBAC7B,WAAW,WAAW,SAAS;gBAC/B,UAAU,WAAW,QAAQ;gBAC7B,aAAa,eAAe,WAAW,QAAQ;gBAC/C,MAAM,WAAW,IAAI;gBACrB,QAAQ;YACV;QACF;IACF;IAEA;QACE,MAAM,QAAQ;QACd,MAAM,YAAY,MAAM,IAAI,CAC1B,CAAC,OAAS,KAAK,KAAK,KAAK,wBAAwB,KAAK,QAAQ,KAAK;QAGrE,IAAI,CAAC,aAAa,UAAU,QAAQ,KAAK,UAAU;YACjD,OAAO;gBAAE,IAAI;gBAAO,OAAO;YAAkC;QAC/D;QAEA,MAAM,OAAiB;YACrB,OAAO,UAAU,KAAK;YACtB,UAAU,UAAU,QAAQ;YAC5B,aAAa,UAAU,QAAQ;YAC/B,MAAM,UAAU,IAAI;YACpB,QAAQ;QACV;QAEA,OAAO;YAAE,IAAI;YAAM;QAAK;IAC1B;AACF"}},
    {"offset": {"line": 402, "column": 0}, "map": {"version":3,"sources":["file:///home/alabrador/dashboard-ansible-ia/src/lib/auth/ldap-auth.ts"],"sourcesContent":["import { Client } from \"ldapts\";\nimport type { AuthResult, AuthUser } from \"@/lib/auth/types\";\n\ntype LdapConfig = {\n  url: string;\n  baseDn: string;\n  userFilter: string;\n  bindDn?: string;\n  bindPassword?: string;\n  timeoutMs: number;\n};\n\nfunction getLdapConfig(): LdapConfig | null {\n  const url = process.env.LDAP_URL?.trim();\n  const baseDn = process.env.LDAP_BASE_DN?.trim();\n\n  if (!url || !baseDn) {\n    return null;\n  }\n\n  return {\n    url,\n    baseDn,\n    userFilter: process.env.LDAP_USER_FILTER?.trim() || \"(mail={{email}})\",\n    bindDn: process.env.LDAP_BIND_DN?.trim() || undefined,\n    bindPassword: process.env.LDAP_BIND_PASSWORD?.trim() || undefined,\n    timeoutMs: Number(process.env.LDAP_TIMEOUT_MS ?? 5000),\n  };\n}\n\nfunction buildFilter(template: string, email: string): string {\n  return template.replace(/\\{\\{\\s*email\\s*\\}\\}/gi, email);\n}\n\nfunction resolveLdapRole(email: string): \"administrativo\" | \"tecnico\" {\n  const adminList = (process.env.LDAP_ADMIN_EMAILS ?? \"\")\n    .split(\";\")\n    .map((item) => item.trim().toLowerCase())\n    .filter(Boolean);\n\n  return adminList.includes(email.trim().toLowerCase()) ? \"administrativo\" : \"tecnico\";\n}\n\nexport function isLdapEnabled(): boolean {\n  return getLdapConfig() !== null;\n}\n\nexport async function authenticateLdap(email: string, password: string): Promise<AuthResult> {\n  const config = getLdapConfig();\n  if (!config) {\n    return { ok: false, error: \"LDAP no está configurado.\" };\n  }\n\n  const normalizedEmail = email.trim().toLowerCase();\n  const client = new Client({\n    url: config.url,\n    timeout: config.timeoutMs,\n    connectTimeout: config.timeoutMs,\n  });\n\n  try {\n    if (config.bindDn && config.bindPassword) {\n      await client.bind(config.bindDn, config.bindPassword);\n    } else {\n      await client.bind(normalizedEmail, password);\n      const directUser: AuthUser = {\n        email: normalizedEmail,\n        role: resolveLdapRole(normalizedEmail),\n        source: \"ldap\",\n      };\n      return { ok: true, user: directUser };\n    }\n\n    const filter = buildFilter(config.userFilter, normalizedEmail);\n    const searchResult = await client.search(config.baseDn, {\n      scope: \"sub\",\n      filter,\n      attributes: [\"dn\", \"mail\"],\n      sizeLimit: 1,\n    });\n\n    const entry = searchResult.searchEntries[0];\n    if (!entry || typeof entry.dn !== \"string\") {\n      return { ok: false, error: \"Usuario no encontrado en LDAP.\" };\n    }\n\n    const userDn = entry.dn;\n    await client.unbind();\n\n    const authClient = new Client({\n      url: config.url,\n      timeout: config.timeoutMs,\n      connectTimeout: config.timeoutMs,\n    });\n\n    try {\n      await authClient.bind(userDn, password);\n      const user: AuthUser = {\n        email:\n          typeof entry.mail === \"string\" && entry.mail.trim()\n            ? entry.mail.toLowerCase()\n            : normalizedEmail,\n        role: resolveLdapRole(\n          typeof entry.mail === \"string\" && entry.mail.trim()\n            ? entry.mail.toLowerCase()\n            : normalizedEmail,\n        ),\n        source: \"ldap\",\n      };\n\n      return { ok: true, user };\n    } finally {\n      await authClient.unbind();\n    }\n  } catch {\n    return { ok: false, error: \"Credenciales LDAP inválidas o servidor no disponible.\" };\n  } finally {\n    try {\n      await client.unbind();\n    } catch {\n      // noop\n    }\n  }\n}"],"names":[],"mappings":"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"}},
    {"offset": {"line": 519, "column": 0}, "map": {"version":3,"sources":["file:///home/alabrador/dashboard-ansible-ia/src/lib/auth/session.ts"],"sourcesContent":["import { jwtVerify, SignJWT } from \"jose\";\nimport type { AuthUser } from \"@/lib/auth/types\";\n\nconst SESSION_COOKIE_NAME = \"dashboard_session\";\nconst SESSION_DURATION_SECONDS = 60 * 60 * 12;\n\nfunction getJwtSecret(): Uint8Array {\n  const secret = process.env.AUTH_JWT_SECRET;\n  if (!secret) {\n    throw new Error(\"Falta AUTH_JWT_SECRET en variables de entorno.\");\n  }\n\n  return new TextEncoder().encode(secret);\n}\n\nexport function getSessionCookieName(): string {\n  return SESSION_COOKIE_NAME;\n}\n\nexport async function createSessionToken(user: AuthUser): Promise<string> {\n  const secret = getJwtSecret();\n\n  return new SignJWT({\n    email: user.email,\n    source: user.source,\n    username: user.username,\n    firstName: user.firstName,\n    lastName: user.lastName,\n    displayName: user.displayName,\n    role: user.role,\n  })\n    .setProtectedHeader({ alg: \"HS256\" })\n    .setSubject(user.email)\n    .setIssuedAt()\n    .setExpirationTime(`${SESSION_DURATION_SECONDS}s`)\n    .sign(secret);\n}\n\nexport async function verifySessionToken(token: string): Promise<AuthUser | null> {\n  try {\n    const secret = getJwtSecret();\n    const { payload } = await jwtVerify(token, secret);\n\n    const email = typeof payload.email === \"string\" ? payload.email : null;\n    const source = payload.source === \"ldap\" || payload.source === \"local\" ? payload.source : null;\n    const username = typeof payload.username === \"string\" ? payload.username : undefined;\n    const firstName = typeof payload.firstName === \"string\" ? payload.firstName : undefined;\n    const lastName = typeof payload.lastName === \"string\" ? payload.lastName : undefined;\n    const displayName = typeof payload.displayName === \"string\" ? payload.displayName : undefined;\n    const role = payload.role === \"administrativo\" || payload.role === \"tecnico\" ? payload.role : undefined;\n\n    if (!email || !source) {\n      return null;\n    }\n\n    return { email, source, username, firstName, lastName, displayName, role };\n  } catch {\n    return null;\n  }\n}\n\nexport function getSessionMaxAge(): number {\n  return SESSION_DURATION_SECONDS;\n}"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;;AAGA,MAAM,sBAAsB;AAC5B,MAAM,2BAA2B,KAAK,KAAK;AAE3C,SAAS;IACP,MAAM,SAAS,QAAQ,GAAG,CAAC,eAAe;IAC1C,IAAI,CAAC,QAAQ;QACX,MAAM,IAAI,MAAM;IAClB;IAEA,OAAO,IAAI,cAAc,MAAM,CAAC;AAClC;AAEO,SAAS;IACd,OAAO;AACT;AAEO,eAAe,mBAAmB,IAAc;IACrD,MAAM,SAAS;IAEf,OAAO,IAAI,kKAAO,CAAC;QACjB,OAAO,KAAK,KAAK;QACjB,QAAQ,KAAK,MAAM;QACnB,UAAU,KAAK,QAAQ;QACvB,WAAW,KAAK,SAAS;QACzB,UAAU,KAAK,QAAQ;QACvB,aAAa,KAAK,WAAW;QAC7B,MAAM,KAAK,IAAI;IACjB,GACG,kBAAkB,CAAC;QAAE,KAAK;IAAQ,GAClC,UAAU,CAAC,KAAK,KAAK,EACrB,WAAW,GACX,iBAAiB,CAAC,GAAG,yBAAyB,CAAC,CAAC,EAChD,IAAI,CAAC;AACV;AAEO,eAAe,mBAAmB,KAAa;IACpD,IAAI;QACF,MAAM,SAAS;QACf,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM,IAAA,sKAAS,EAAC,OAAO;QAE3C,MAAM,QAAQ,OAAO,QAAQ,KAAK,KAAK,WAAW,QAAQ,KAAK,GAAG;QAClE,MAAM,SAAS,QAAQ,MAAM,KAAK,UAAU,QAAQ,MAAM,KAAK,UAAU,QAAQ,MAAM,GAAG;QAC1F,MAAM,WAAW,OAAO,QAAQ,QAAQ,KAAK,WAAW,QAAQ,QAAQ,GAAG;QAC3E,MAAM,YAAY,OAAO,QAAQ,SAAS,KAAK,WAAW,QAAQ,SAAS,GAAG;QAC9E,MAAM,WAAW,OAAO,QAAQ,QAAQ,KAAK,WAAW,QAAQ,QAAQ,GAAG;QAC3E,MAAM,cAAc,OAAO,QAAQ,WAAW,KAAK,WAAW,QAAQ,WAAW,GAAG;QACpF,MAAM,OAAO,QAAQ,IAAI,KAAK,oBAAoB,QAAQ,IAAI,KAAK,YAAY,QAAQ,IAAI,GAAG;QAE9F,IAAI,CAAC,SAAS,CAAC,QAAQ;YACrB,OAAO;QACT;QAEA,OAAO;YAAE;YAAO;YAAQ;YAAU;YAAW;YAAU;YAAa;QAAK;IAC3E,EAAE,OAAM;QACN,OAAO;IACT;AACF;AAEO,SAAS;IACd,OAAO;AACT"}},
    {"offset": {"line": 592, "column": 0}, "map": {"version":3,"sources":["file:///home/alabrador/dashboard-ansible-ia/src/lib/auth/cookies.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\nimport { getSessionCookieName, getSessionMaxAge } from \"@/lib/auth/session\";\n\nexport function setSessionCookie(response: NextResponse, token: string) {\n  response.cookies.set({\n    name: getSessionCookieName(),\n    value: token,\n    httpOnly: true,\n    secure: process.env.NODE_ENV === \"production\",\n    sameSite: \"lax\",\n    path: \"/\",\n    maxAge: getSessionMaxAge(),\n  });\n}\n\nexport function clearSessionCookie(response: NextResponse) {\n  response.cookies.set({\n    name: getSessionCookieName(),\n    value: \"\",\n    httpOnly: true,\n    secure: process.env.NODE_ENV === \"production\",\n    sameSite: \"lax\",\n    path: \"/\",\n    maxAge: 0,\n  });\n}"],"names":[],"mappings":";;;;;;AACA;;AAEO,SAAS,iBAAiB,QAAsB,EAAE,KAAa;IACpE,SAAS,OAAO,CAAC,GAAG,CAAC;QACnB,MAAM,IAAA,uJAAoB;QAC1B,OAAO;QACP,UAAU;QACV,QAAQ,oDAAyB;QACjC,UAAU;QACV,MAAM;QACN,QAAQ,IAAA,mJAAgB;IAC1B;AACF;AAEO,SAAS,mBAAmB,QAAsB;IACvD,SAAS,OAAO,CAAC,GAAG,CAAC;QACnB,MAAM,IAAA,uJAAoB;QAC1B,OAAO;QACP,UAAU;QACV,QAAQ,oDAAyB;QACjC,UAAU;QACV,MAAM;QACN,QAAQ;IACV;AACF"}},
    {"offset": {"line": 626, "column": 0}, "map": {"version":3,"sources":["file:///home/alabrador/dashboard-ansible-ia/src/app/api/auth/login/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\nimport { authenticateLocal } from \"@/lib/auth/local-auth\";\nimport { authenticateLdap, isLdapEnabled } from \"@/lib/auth/ldap-auth\";\nimport { createSessionToken } from \"@/lib/auth/session\";\nimport { setSessionCookie } from \"@/lib/auth/cookies\";\n\ntype LoginBody = {\n  email?: string;\n  username?: string;\n  password?: string;\n};\n\nconst AUTH_NO_CACHE_HEADERS: HeadersInit = {\n  \"Cache-Control\": \"private, no-store, no-cache, must-revalidate, max-age=0\",\n  Pragma: \"no-cache\",\n  Expires: \"0\",\n  Vary: \"Cookie\",\n};\n\nexport async function POST(request: Request) {\n  try {\n    if (!process.env.AUTH_JWT_SECRET?.trim()) {\n      return NextResponse.json(\n        { error: \"Falta AUTH_JWT_SECRET en .env.local para crear la sesión.\" },\n        { status: 500, headers: AUTH_NO_CACHE_HEADERS },\n      );\n    }\n\n    const body = (await request.json()) as LoginBody;\n    const identifier = (body.username ?? body.email ?? \"\").trim().toLowerCase();\n    const password = body.password?.trim() ?? \"\";\n\n    if (!identifier || !password) {\n      return NextResponse.json(\n        { error: \"Debes ingresar usuario/correo y contraseña.\" },\n        { status: 400, headers: AUTH_NO_CACHE_HEADERS },\n      );\n    }\n\n    const localResult = await authenticateLocal(identifier, password);\n    if (localResult.ok && localResult.user) {\n      const token = await createSessionToken(localResult.user);\n      const response = NextResponse.json(\n        { ok: true, source: \"local\", user: localResult.user },\n        { headers: AUTH_NO_CACHE_HEADERS },\n      );\n      setSessionCookie(response, token);\n      return response;\n    }\n\n    if (isLdapEnabled()) {\n      const ldapResult = await authenticateLdap(identifier, password);\n      if (ldapResult.ok && ldapResult.user) {\n        const token = await createSessionToken(ldapResult.user);\n        const response = NextResponse.json(\n          { ok: true, source: \"ldap\", user: ldapResult.user },\n          { headers: AUTH_NO_CACHE_HEADERS },\n        );\n        setSessionCookie(response, token);\n        return response;\n      }\n    }\n\n    return NextResponse.json(\n      { error: \"Credenciales inválidas.\" },\n      { status: 401, headers: AUTH_NO_CACHE_HEADERS },\n    );\n  } catch (error) {\n    const detail =\n      error instanceof Error && error.message\n        ? error.message\n        : \"No se pudo procesar el login.\";\n\n    return NextResponse.json(\n      { error: detail },\n      { status: 500, headers: AUTH_NO_CACHE_HEADERS },\n    );\n  }\n}"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAQA,MAAM,wBAAqC;IACzC,iBAAiB;IACjB,QAAQ;IACR,SAAS;IACT,MAAM;AACR;AAEO,eAAe,KAAK,OAAgB;IACzC,IAAI;QACF,IAAI,CAAC,QAAQ,GAAG,CAAC,eAAe,EAAE,QAAQ;YACxC,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA4D,GACrE;gBAAE,QAAQ;gBAAK,SAAS;YAAsB;QAElD;QAEA,MAAM,OAAQ,MAAM,QAAQ,IAAI;QAChC,MAAM,aAAa,CAAC,KAAK,QAAQ,IAAI,KAAK,KAAK,IAAI,EAAE,EAAE,IAAI,GAAG,WAAW;QACzE,MAAM,WAAW,KAAK,QAAQ,EAAE,UAAU;QAE1C,IAAI,CAAC,cAAc,CAAC,UAAU;YAC5B,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA8C,GACvD;gBAAE,QAAQ;gBAAK,SAAS;YAAsB;QAElD;QAEA,MAAM,cAAc,MAAM,IAAA,0JAAiB,EAAC,YAAY;QACxD,IAAI,YAAY,EAAE,IAAI,YAAY,IAAI,EAAE;YACtC,MAAM,QAAQ,MAAM,IAAA,qJAAkB,EAAC,YAAY,IAAI;YACvD,MAAM,WAAW,gJAAY,CAAC,IAAI,CAChC;gBAAE,IAAI;gBAAM,QAAQ;gBAAS,MAAM,YAAY,IAAI;YAAC,GACpD;gBAAE,SAAS;YAAsB;YAEnC,IAAA,mJAAgB,EAAC,UAAU;YAC3B,OAAO;QACT;QAEA,IAAI,IAAA,qJAAa,KAAI;YACnB,MAAM,aAAa,MAAM,IAAA,wJAAgB,EAAC,YAAY;YACtD,IAAI,WAAW,EAAE,IAAI,WAAW,IAAI,EAAE;gBACpC,MAAM,QAAQ,MAAM,IAAA,qJAAkB,EAAC,WAAW,IAAI;gBACtD,MAAM,WAAW,gJAAY,CAAC,IAAI,CAChC;oBAAE,IAAI;oBAAM,QAAQ;oBAAQ,MAAM,WAAW,IAAI;gBAAC,GAClD;oBAAE,SAAS;gBAAsB;gBAEnC,IAAA,mJAAgB,EAAC,UAAU;gBAC3B,OAAO;YACT;QACF;QAEA,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAA0B,GACnC;YAAE,QAAQ;YAAK,SAAS;QAAsB;IAElD,EAAE,OAAO,OAAO;QACd,MAAM,SACJ,iBAAiB,SAAS,MAAM,OAAO,GACnC,MAAM,OAAO,GACb;QAEN,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAO,GAChB;YAAE,QAAQ;YAAK,SAAS;QAAsB;IAElD;AACF"}}]
}