{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 70, "column": 0}, "map": {"version":3,"sources":["file:///home/alabrador/dashboard-ansible-ia/src/lib/auth/local-user-store.ts"],"sourcesContent":["import { randomBytes, scrypt as scryptCallback, timingSafeEqual } from \"node:crypto\";\nimport { promises as fs } from \"node:fs\";\nimport { join } from \"node:path\";\nimport { promisify } from \"node:util\";\n\nconst scrypt = promisify(scryptCallback);\nconst STORE_DIR = join(process.cwd(), \"uploads\");\nconst STORE_PATH = join(STORE_DIR, \"local-users.json\");\n\ntype StoredLocalUser = {\n  email: string;\n  passwordHash: string;\n  salt: string;\n};\n\ntype StoredLocalUserFile = {\n  users: StoredLocalUser[];\n};\n\nasync function ensureStoreFile(): Promise<void> {\n  await fs.mkdir(STORE_DIR, { recursive: true });\n\n  try {\n    await fs.access(STORE_PATH);\n  } catch {\n    const initialData: StoredLocalUserFile = { users: [] };\n    await fs.writeFile(STORE_PATH, JSON.stringify(initialData, null, 2), \"utf8\");\n  }\n}\n\nasync function readStore(): Promise<StoredLocalUserFile> {\n  await ensureStoreFile();\n  const raw = await fs.readFile(STORE_PATH, \"utf8\");\n\n  try {\n    const parsed = JSON.parse(raw) as StoredLocalUserFile;\n    if (!parsed || !Array.isArray(parsed.users)) {\n      return { users: [] };\n    }\n\n    return {\n      users: parsed.users.filter(\n        (item) =>\n          typeof item?.email === \"string\" &&\n          typeof item?.passwordHash === \"string\" &&\n          typeof item?.salt === \"string\",\n      ),\n    };\n  } catch {\n    return { users: [] };\n  }\n}\n\nasync function writeStore(data: StoredLocalUserFile): Promise<void> {\n  await ensureStoreFile();\n  await fs.writeFile(STORE_PATH, JSON.stringify(data, null, 2), \"utf8\");\n}\n\nasync function hashPassword(password: string, salt: string): Promise<string> {\n  const derivedKey = (await scrypt(password, salt, 64)) as Buffer;\n  return derivedKey.toString(\"hex\");\n}\n\nexport async function listStoredLocalUserEmails(): Promise<string[]> {\n  const store = await readStore();\n  return store.users.map((user) => user.email).sort((a, b) => a.localeCompare(b));\n}\n\nexport async function upsertStoredLocalUser(email: string, password: string): Promise<void> {\n  const normalizedEmail = email.trim().toLowerCase();\n  const salt = randomBytes(16).toString(\"hex\");\n  const passwordHash = await hashPassword(password, salt);\n\n  const store = await readStore();\n  const nextUsers = store.users.filter((user) => user.email !== normalizedEmail);\n  nextUsers.push({ email: normalizedEmail, passwordHash, salt });\n\n  await writeStore({ users: nextUsers });\n}\n\nexport async function removeStoredLocalUser(email: string): Promise<boolean> {\n  const normalizedEmail = email.trim().toLowerCase();\n  const store = await readStore();\n  const nextUsers = store.users.filter((user) => user.email !== normalizedEmail);\n\n  if (nextUsers.length === store.users.length) {\n    return false;\n  }\n\n  await writeStore({ users: nextUsers });\n  return true;\n}\n\nexport async function verifyStoredLocalUser(email: string, password: string): Promise<boolean> {\n  const normalizedEmail = email.trim().toLowerCase();\n  const store = await readStore();\n  const user = store.users.find((item) => item.email === normalizedEmail);\n\n  if (!user) {\n    return false;\n  }\n\n  const providedHash = await hashPassword(password, user.salt);\n  const expected = Buffer.from(user.passwordHash, \"hex\");\n  const actual = Buffer.from(providedHash, \"hex\");\n\n  if (expected.length !== actual.length) {\n    return false;\n  }\n\n  return timingSafeEqual(expected, actual);\n}"],"names":[],"mappings":"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"}},
    {"offset": {"line": 181, "column": 0}, "map": {"version":3,"sources":["file:///home/alabrador/dashboard-ansible-ia/src/lib/auth/local-auth.ts"],"sourcesContent":["import type { AuthResult, AuthUser } from \"@/lib/auth/types\";\nimport { verifyStoredLocalUser } from \"@/lib/auth/local-user-store\";\n\ntype LocalCredential = {\n  email: string;\n  password: string;\n};\n\nfunction parseLocalUsers(): LocalCredential[] {\n  const raw = process.env.LOCAL_AUTH_USERS ?? \"\";\n  if (!raw.trim()) {\n    return [];\n  }\n\n  return raw\n    .split(\";\")\n    .map((entry) => entry.trim())\n    .filter(Boolean)\n    .map((entry) => {\n      const separator = entry.indexOf(\":\");\n      if (separator <= 0) {\n        return null;\n      }\n\n      const email = entry.slice(0, separator).trim().toLowerCase();\n      const password = entry.slice(separator + 1).trim();\n\n      if (!email || !password) {\n        return null;\n      }\n\n      return { email, password };\n    })\n    .filter((item): item is LocalCredential => item !== null);\n}\n\nexport async function authenticateLocal(email: string, password: string): Promise<AuthResult> {\n  const normalizedEmail = email.trim().toLowerCase();\n  const storedUserOk = await verifyStoredLocalUser(normalizedEmail, password);\n\n  if (!storedUserOk) {\n    const users = parseLocalUsers();\n    const localUser = users.find((user) => user.email === normalizedEmail);\n\n    if (!localUser || localUser.password !== password) {\n      return { ok: false, error: \"Credenciales locales inválidas.\" };\n    }\n  }\n\n  const user: AuthUser = {\n    email: normalizedEmail,\n    source: \"local\",\n  };\n\n  return { ok: true, user };\n}"],"names":[],"mappings":";;;;AACA;;AAOA,SAAS;IACP,MAAM,MAAM,QAAQ,GAAG,CAAC,gBAAgB,IAAI;IAC5C,IAAI,CAAC,IAAI,IAAI,IAAI;QACf,OAAO,EAAE;IACX;IAEA,OAAO,IACJ,KAAK,CAAC,KACN,GAAG,CAAC,CAAC,QAAU,MAAM,IAAI,IACzB,MAAM,CAAC,SACP,GAAG,CAAC,CAAC;QACJ,MAAM,YAAY,MAAM,OAAO,CAAC;QAChC,IAAI,aAAa,GAAG;YAClB,OAAO;QACT;QAEA,MAAM,QAAQ,MAAM,KAAK,CAAC,GAAG,WAAW,IAAI,GAAG,WAAW;QAC1D,MAAM,WAAW,MAAM,KAAK,CAAC,YAAY,GAAG,IAAI;QAEhD,IAAI,CAAC,SAAS,CAAC,UAAU;YACvB,OAAO;QACT;QAEA,OAAO;YAAE;YAAO;QAAS;IAC3B,GACC,MAAM,CAAC,CAAC,OAAkC,SAAS;AACxD;AAEO,eAAe,kBAAkB,KAAa,EAAE,QAAgB;IACrE,MAAM,kBAAkB,MAAM,IAAI,GAAG,WAAW;IAChD,MAAM,eAAe,MAAM,IAAA,uKAAqB,EAAC,iBAAiB;IAElE,IAAI,CAAC,cAAc;QACjB,MAAM,QAAQ;QACd,MAAM,YAAY,MAAM,IAAI,CAAC,CAAC,OAAS,KAAK,KAAK,KAAK;QAEtD,IAAI,CAAC,aAAa,UAAU,QAAQ,KAAK,UAAU;YACjD,OAAO;gBAAE,IAAI;gBAAO,OAAO;YAAkC;QAC/D;IACF;IAEA,MAAM,OAAiB;QACrB,OAAO;QACP,QAAQ;IACV;IAEA,OAAO;QAAE,IAAI;QAAM;IAAK;AAC1B"}},
    {"offset": {"line": 258, "column": 0}, "map": {"version":3,"sources":["file:///home/alabrador/dashboard-ansible-ia/src/lib/auth/ldap-auth.ts"],"sourcesContent":["import { Client } from \"ldapts\";\nimport type { AuthResult, AuthUser } from \"@/lib/auth/types\";\n\ntype LdapConfig = {\n  url: string;\n  baseDn: string;\n  userFilter: string;\n  bindDn?: string;\n  bindPassword?: string;\n  timeoutMs: number;\n};\n\nfunction getLdapConfig(): LdapConfig | null {\n  const url = process.env.LDAP_URL?.trim();\n  const baseDn = process.env.LDAP_BASE_DN?.trim();\n\n  if (!url || !baseDn) {\n    return null;\n  }\n\n  return {\n    url,\n    baseDn,\n    userFilter: process.env.LDAP_USER_FILTER?.trim() || \"(mail={{email}})\",\n    bindDn: process.env.LDAP_BIND_DN?.trim() || undefined,\n    bindPassword: process.env.LDAP_BIND_PASSWORD?.trim() || undefined,\n    timeoutMs: Number(process.env.LDAP_TIMEOUT_MS ?? 5000),\n  };\n}\n\nfunction buildFilter(template: string, email: string): string {\n  return template.replace(/\\{\\{\\s*email\\s*\\}\\}/gi, email);\n}\n\nexport function isLdapEnabled(): boolean {\n  return getLdapConfig() !== null;\n}\n\nexport async function authenticateLdap(email: string, password: string): Promise<AuthResult> {\n  const config = getLdapConfig();\n  if (!config) {\n    return { ok: false, error: \"LDAP no está configurado.\" };\n  }\n\n  const normalizedEmail = email.trim().toLowerCase();\n  const client = new Client({\n    url: config.url,\n    timeout: config.timeoutMs,\n    connectTimeout: config.timeoutMs,\n  });\n\n  try {\n    if (config.bindDn && config.bindPassword) {\n      await client.bind(config.bindDn, config.bindPassword);\n    } else {\n      await client.bind(normalizedEmail, password);\n      const directUser: AuthUser = { email: normalizedEmail, source: \"ldap\" };\n      return { ok: true, user: directUser };\n    }\n\n    const filter = buildFilter(config.userFilter, normalizedEmail);\n    const searchResult = await client.search(config.baseDn, {\n      scope: \"sub\",\n      filter,\n      attributes: [\"dn\", \"mail\"],\n      sizeLimit: 1,\n    });\n\n    const entry = searchResult.searchEntries[0];\n    if (!entry || typeof entry.dn !== \"string\") {\n      return { ok: false, error: \"Usuario no encontrado en LDAP.\" };\n    }\n\n    const userDn = entry.dn;\n    await client.unbind();\n\n    const authClient = new Client({\n      url: config.url,\n      timeout: config.timeoutMs,\n      connectTimeout: config.timeoutMs,\n    });\n\n    try {\n      await authClient.bind(userDn, password);\n      const user: AuthUser = {\n        email:\n          typeof entry.mail === \"string\" && entry.mail.trim()\n            ? entry.mail.toLowerCase()\n            : normalizedEmail,\n        source: \"ldap\",\n      };\n\n      return { ok: true, user };\n    } finally {\n      await authClient.unbind();\n    }\n  } catch {\n    return { ok: false, error: \"Credenciales LDAP inválidas o servidor no disponible.\" };\n  } finally {\n    try {\n      await client.unbind();\n    } catch {\n      // noop\n    }\n  }\n}"],"names":[],"mappings":";;;;;;AAAA;;AAYA,SAAS;IACP,MAAM,MAAM,QAAQ,GAAG,CAAC,QAAQ,EAAE;IAClC,MAAM,SAAS,QAAQ,GAAG,CAAC,YAAY,EAAE;IAEzC,IAAI,CAAC,OAAO,CAAC,QAAQ;QACnB,OAAO;IACT;IAEA,OAAO;QACL;QACA;QACA,YAAY,QAAQ,GAAG,CAAC,gBAAgB,EAAE,UAAU;QACpD,QAAQ,QAAQ,GAAG,CAAC,YAAY,EAAE,UAAU;QAC5C,cAAc,QAAQ,GAAG,CAAC,kBAAkB,EAAE,UAAU;QACxD,WAAW,OAAO,QAAQ,GAAG,CAAC,eAAe,IAAI;IACnD;AACF;AAEA,SAAS,YAAY,QAAgB,EAAE,KAAa;IAClD,OAAO,SAAS,OAAO,CAAC,yBAAyB;AACnD;AAEO,SAAS;IACd,OAAO,oBAAoB;AAC7B;AAEO,eAAe,iBAAiB,KAAa,EAAE,QAAgB;IACpE,MAAM,SAAS;IACf,IAAI,CAAC,QAAQ;QACX,OAAO;YAAE,IAAI;YAAO,OAAO;QAA4B;IACzD;IAEA,MAAM,kBAAkB,MAAM,IAAI,GAAG,WAAW;IAChD,MAAM,SAAS,IAAI,oJAAM,CAAC;QACxB,KAAK,OAAO,GAAG;QACf,SAAS,OAAO,SAAS;QACzB,gBAAgB,OAAO,SAAS;IAClC;IAEA,IAAI;QACF,IAAI,OAAO,MAAM,IAAI,OAAO,YAAY,EAAE;YACxC,MAAM,OAAO,IAAI,CAAC,OAAO,MAAM,EAAE,OAAO,YAAY;QACtD,OAAO;YACL,MAAM,OAAO,IAAI,CAAC,iBAAiB;YACnC,MAAM,aAAuB;gBAAE,OAAO;gBAAiB,QAAQ;YAAO;YACtE,OAAO;gBAAE,IAAI;gBAAM,MAAM;YAAW;QACtC;QAEA,MAAM,SAAS,YAAY,OAAO,UAAU,EAAE;QAC9C,MAAM,eAAe,MAAM,OAAO,MAAM,CAAC,OAAO,MAAM,EAAE;YACtD,OAAO;YACP;YACA,YAAY;gBAAC;gBAAM;aAAO;YAC1B,WAAW;QACb;QAEA,MAAM,QAAQ,aAAa,aAAa,CAAC,EAAE;QAC3C,IAAI,CAAC,SAAS,OAAO,MAAM,EAAE,KAAK,UAAU;YAC1C,OAAO;gBAAE,IAAI;gBAAO,OAAO;YAAiC;QAC9D;QAEA,MAAM,SAAS,MAAM,EAAE;QACvB,MAAM,OAAO,MAAM;QAEnB,MAAM,aAAa,IAAI,oJAAM,CAAC;YAC5B,KAAK,OAAO,GAAG;YACf,SAAS,OAAO,SAAS;YACzB,gBAAgB,OAAO,SAAS;QAClC;QAEA,IAAI;YACF,MAAM,WAAW,IAAI,CAAC,QAAQ;YAC9B,MAAM,OAAiB;gBACrB,OACE,OAAO,MAAM,IAAI,KAAK,YAAY,MAAM,IAAI,CAAC,IAAI,KAC7C,MAAM,IAAI,CAAC,WAAW,KACtB;gBACN,QAAQ;YACV;YAEA,OAAO;gBAAE,IAAI;gBAAM;YAAK;QAC1B,SAAU;YACR,MAAM,WAAW,MAAM;QACzB;IACF,EAAE,OAAM;QACN,OAAO;YAAE,IAAI;YAAO,OAAO;QAAwD;IACrF,SAAU;QACR,IAAI;YACF,MAAM,OAAO,MAAM;QACrB,EAAE,OAAM;QACN,OAAO;QACT;IACF;AACF"}},
    {"offset": {"line": 369, "column": 0}, "map": {"version":3,"sources":["file:///home/alabrador/dashboard-ansible-ia/src/lib/auth/session.ts"],"sourcesContent":["import { jwtVerify, SignJWT } from \"jose\";\nimport type { AuthUser } from \"@/lib/auth/types\";\n\nconst SESSION_COOKIE_NAME = \"dashboard_session\";\nconst SESSION_DURATION_SECONDS = 60 * 60 * 12;\n\nfunction getJwtSecret(): Uint8Array {\n  const secret = process.env.AUTH_JWT_SECRET;\n  if (!secret) {\n    throw new Error(\"Falta AUTH_JWT_SECRET en variables de entorno.\");\n  }\n\n  return new TextEncoder().encode(secret);\n}\n\nexport function getSessionCookieName(): string {\n  return SESSION_COOKIE_NAME;\n}\n\nexport async function createSessionToken(user: AuthUser): Promise<string> {\n  const secret = getJwtSecret();\n\n  return new SignJWT({ email: user.email, source: user.source })\n    .setProtectedHeader({ alg: \"HS256\" })\n    .setSubject(user.email)\n    .setIssuedAt()\n    .setExpirationTime(`${SESSION_DURATION_SECONDS}s`)\n    .sign(secret);\n}\n\nexport async function verifySessionToken(token: string): Promise<AuthUser | null> {\n  try {\n    const secret = getJwtSecret();\n    const { payload } = await jwtVerify(token, secret);\n\n    const email = typeof payload.email === \"string\" ? payload.email : null;\n    const source = payload.source === \"ldap\" || payload.source === \"local\" ? payload.source : null;\n\n    if (!email || !source) {\n      return null;\n    }\n\n    return { email, source };\n  } catch {\n    return null;\n  }\n}\n\nexport function getSessionMaxAge(): number {\n  return SESSION_DURATION_SECONDS;\n}"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;;AAGA,MAAM,sBAAsB;AAC5B,MAAM,2BAA2B,KAAK,KAAK;AAE3C,SAAS;IACP,MAAM,SAAS,QAAQ,GAAG,CAAC,eAAe;IAC1C,IAAI,CAAC,QAAQ;QACX,MAAM,IAAI,MAAM;IAClB;IAEA,OAAO,IAAI,cAAc,MAAM,CAAC;AAClC;AAEO,SAAS;IACd,OAAO;AACT;AAEO,eAAe,mBAAmB,IAAc;IACrD,MAAM,SAAS;IAEf,OAAO,IAAI,kKAAO,CAAC;QAAE,OAAO,KAAK,KAAK;QAAE,QAAQ,KAAK,MAAM;IAAC,GACzD,kBAAkB,CAAC;QAAE,KAAK;IAAQ,GAClC,UAAU,CAAC,KAAK,KAAK,EACrB,WAAW,GACX,iBAAiB,CAAC,GAAG,yBAAyB,CAAC,CAAC,EAChD,IAAI,CAAC;AACV;AAEO,eAAe,mBAAmB,KAAa;IACpD,IAAI;QACF,MAAM,SAAS;QACf,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM,IAAA,sKAAS,EAAC,OAAO;QAE3C,MAAM,QAAQ,OAAO,QAAQ,KAAK,KAAK,WAAW,QAAQ,KAAK,GAAG;QAClE,MAAM,SAAS,QAAQ,MAAM,KAAK,UAAU,QAAQ,MAAM,KAAK,UAAU,QAAQ,MAAM,GAAG;QAE1F,IAAI,CAAC,SAAS,CAAC,QAAQ;YACrB,OAAO;QACT;QAEA,OAAO;YAAE;YAAO;QAAO;IACzB,EAAE,OAAM;QACN,OAAO;IACT;AACF;AAEO,SAAS;IACd,OAAO;AACT"}},
    {"offset": {"line": 427, "column": 0}, "map": {"version":3,"sources":["file:///home/alabrador/dashboard-ansible-ia/src/lib/auth/cookies.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\nimport { getSessionCookieName, getSessionMaxAge } from \"@/lib/auth/session\";\n\nexport function setSessionCookie(response: NextResponse, token: string) {\n  response.cookies.set({\n    name: getSessionCookieName(),\n    value: token,\n    httpOnly: true,\n    secure: process.env.NODE_ENV === \"production\",\n    sameSite: \"lax\",\n    path: \"/\",\n    maxAge: getSessionMaxAge(),\n  });\n}\n\nexport function clearSessionCookie(response: NextResponse) {\n  response.cookies.set({\n    name: getSessionCookieName(),\n    value: \"\",\n    httpOnly: true,\n    secure: process.env.NODE_ENV === \"production\",\n    sameSite: \"lax\",\n    path: \"/\",\n    maxAge: 0,\n  });\n}"],"names":[],"mappings":";;;;;;AACA;;AAEO,SAAS,iBAAiB,QAAsB,EAAE,KAAa;IACpE,SAAS,OAAO,CAAC,GAAG,CAAC;QACnB,MAAM,IAAA,uJAAoB;QAC1B,OAAO;QACP,UAAU;QACV,QAAQ,oDAAyB;QACjC,UAAU;QACV,MAAM;QACN,QAAQ,IAAA,mJAAgB;IAC1B;AACF;AAEO,SAAS,mBAAmB,QAAsB;IACvD,SAAS,OAAO,CAAC,GAAG,CAAC;QACnB,MAAM,IAAA,uJAAoB;QAC1B,OAAO;QACP,UAAU;QACV,QAAQ,oDAAyB;QACjC,UAAU;QACV,MAAM;QACN,QAAQ;IACV;AACF"}},
    {"offset": {"line": 461, "column": 0}, "map": {"version":3,"sources":["file:///home/alabrador/dashboard-ansible-ia/src/app/api/auth/login/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\nimport { authenticateLocal } from \"@/lib/auth/local-auth\";\nimport { authenticateLdap, isLdapEnabled } from \"@/lib/auth/ldap-auth\";\nimport { createSessionToken } from \"@/lib/auth/session\";\nimport { setSessionCookie } from \"@/lib/auth/cookies\";\n\ntype LoginBody = {\n  email?: string;\n  password?: string;\n};\n\nexport async function POST(request: Request) {\n  try {\n    if (!process.env.AUTH_JWT_SECRET?.trim()) {\n      return NextResponse.json(\n        { error: \"Falta AUTH_JWT_SECRET en .env.local para crear la sesión.\" },\n        { status: 500 },\n      );\n    }\n\n    const body = (await request.json()) as LoginBody;\n    const email = body.email?.trim().toLowerCase() ?? \"\";\n    const password = body.password?.trim() ?? \"\";\n\n    if (!email || !password) {\n      return NextResponse.json(\n        { error: \"Debes ingresar correo y contraseña.\" },\n        { status: 400 },\n      );\n    }\n\n    const localResult = await authenticateLocal(email, password);\n    if (localResult.ok && localResult.user) {\n      const token = await createSessionToken(localResult.user);\n      const response = NextResponse.json({ ok: true, source: \"local\", user: localResult.user });\n      setSessionCookie(response, token);\n      return response;\n    }\n\n    if (isLdapEnabled()) {\n      const ldapResult = await authenticateLdap(email, password);\n      if (ldapResult.ok && ldapResult.user) {\n        const token = await createSessionToken(ldapResult.user);\n        const response = NextResponse.json({ ok: true, source: \"ldap\", user: ldapResult.user });\n        setSessionCookie(response, token);\n        return response;\n      }\n    }\n\n    return NextResponse.json(\n      { error: \"Credenciales inválidas.\" },\n      { status: 401 },\n    );\n  } catch (error) {\n    const detail =\n      error instanceof Error && error.message\n        ? error.message\n        : \"No se pudo procesar el login.\";\n\n    return NextResponse.json(\n      { error: detail },\n      { status: 500 },\n    );\n  }\n}"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAOO,eAAe,KAAK,OAAgB;IACzC,IAAI;QACF,IAAI,CAAC,QAAQ,GAAG,CAAC,eAAe,EAAE,QAAQ;YACxC,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA4D,GACrE;gBAAE,QAAQ;YAAI;QAElB;QAEA,MAAM,OAAQ,MAAM,QAAQ,IAAI;QAChC,MAAM,QAAQ,KAAK,KAAK,EAAE,OAAO,iBAAiB;QAClD,MAAM,WAAW,KAAK,QAAQ,EAAE,UAAU;QAE1C,IAAI,CAAC,SAAS,CAAC,UAAU;YACvB,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAsC,GAC/C;gBAAE,QAAQ;YAAI;QAElB;QAEA,MAAM,cAAc,MAAM,IAAA,0JAAiB,EAAC,OAAO;QACnD,IAAI,YAAY,EAAE,IAAI,YAAY,IAAI,EAAE;YACtC,MAAM,QAAQ,MAAM,IAAA,qJAAkB,EAAC,YAAY,IAAI;YACvD,MAAM,WAAW,gJAAY,CAAC,IAAI,CAAC;gBAAE,IAAI;gBAAM,QAAQ;gBAAS,MAAM,YAAY,IAAI;YAAC;YACvF,IAAA,mJAAgB,EAAC,UAAU;YAC3B,OAAO;QACT;QAEA,IAAI,IAAA,qJAAa,KAAI;YACnB,MAAM,aAAa,MAAM,IAAA,wJAAgB,EAAC,OAAO;YACjD,IAAI,WAAW,EAAE,IAAI,WAAW,IAAI,EAAE;gBACpC,MAAM,QAAQ,MAAM,IAAA,qJAAkB,EAAC,WAAW,IAAI;gBACtD,MAAM,WAAW,gJAAY,CAAC,IAAI,CAAC;oBAAE,IAAI;oBAAM,QAAQ;oBAAQ,MAAM,WAAW,IAAI;gBAAC;gBACrF,IAAA,mJAAgB,EAAC,UAAU;gBAC3B,OAAO;YACT;QACF;QAEA,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAA0B,GACnC;YAAE,QAAQ;QAAI;IAElB,EAAE,OAAO,OAAO;QACd,MAAM,SACJ,iBAAiB,SAAS,MAAM,OAAO,GACnC,MAAM,OAAO,GACb;QAEN,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAO,GAChB;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}