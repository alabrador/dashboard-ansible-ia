{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///home/alabrador/dashboard-ansible-ia/src/lib/auth/session.ts"],"sourcesContent":["import { jwtVerify, SignJWT } from \"jose\";\nimport type { AuthUser } from \"@/lib/auth/types\";\n\nconst SESSION_COOKIE_NAME = \"dashboard_session\";\nconst SESSION_DURATION_SECONDS = 60 * 60 * 12;\n\nfunction getJwtSecret(): Uint8Array {\n  const secret = process.env.AUTH_JWT_SECRET;\n  if (!secret) {\n    throw new Error(\"Falta AUTH_JWT_SECRET en variables de entorno.\");\n  }\n\n  return new TextEncoder().encode(secret);\n}\n\nexport function getSessionCookieName(): string {\n  return SESSION_COOKIE_NAME;\n}\n\nexport async function createSessionToken(user: AuthUser): Promise<string> {\n  const secret = getJwtSecret();\n\n  return new SignJWT({\n    email: user.email,\n    source: user.source,\n    username: user.username,\n    firstName: user.firstName,\n    lastName: user.lastName,\n    displayName: user.displayName,\n    role: user.role,\n  })\n    .setProtectedHeader({ alg: \"HS256\" })\n    .setSubject(user.email)\n    .setIssuedAt()\n    .setExpirationTime(`${SESSION_DURATION_SECONDS}s`)\n    .sign(secret);\n}\n\nexport async function verifySessionToken(token: string): Promise<AuthUser | null> {\n  try {\n    const secret = getJwtSecret();\n    const { payload } = await jwtVerify(token, secret);\n\n    const email = typeof payload.email === \"string\" ? payload.email : null;\n    const source = payload.source === \"ldap\" || payload.source === \"local\" ? payload.source : null;\n    const username = typeof payload.username === \"string\" ? payload.username : undefined;\n    const firstName = typeof payload.firstName === \"string\" ? payload.firstName : undefined;\n    const lastName = typeof payload.lastName === \"string\" ? payload.lastName : undefined;\n    const displayName = typeof payload.displayName === \"string\" ? payload.displayName : undefined;\n    const role = payload.role === \"administrativo\" || payload.role === \"tecnico\" ? payload.role : undefined;\n\n    if (!email || !source) {\n      return null;\n    }\n\n    return { email, source, username, firstName, lastName, displayName, role };\n  } catch {\n    return null;\n  }\n}\n\nexport function getSessionMaxAge(): number {\n  return SESSION_DURATION_SECONDS;\n}"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;;AAGA,MAAM,sBAAsB;AAC5B,MAAM,2BAA2B,KAAK,KAAK;AAE3C,SAAS;IACP,MAAM,SAAS,QAAQ,GAAG,CAAC,eAAe;IAC1C,IAAI,CAAC,QAAQ;QACX,MAAM,IAAI,MAAM;IAClB;IAEA,OAAO,IAAI,cAAc,MAAM,CAAC;AAClC;AAEO,SAAS;IACd,OAAO;AACT;AAEO,eAAe,mBAAmB,IAAc;IACrD,MAAM,SAAS;IAEf,OAAO,IAAI,kKAAO,CAAC;QACjB,OAAO,KAAK,KAAK;QACjB,QAAQ,KAAK,MAAM;QACnB,UAAU,KAAK,QAAQ;QACvB,WAAW,KAAK,SAAS;QACzB,UAAU,KAAK,QAAQ;QACvB,aAAa,KAAK,WAAW;QAC7B,MAAM,KAAK,IAAI;IACjB,GACG,kBAAkB,CAAC;QAAE,KAAK;IAAQ,GAClC,UAAU,CAAC,KAAK,KAAK,EACrB,WAAW,GACX,iBAAiB,CAAC,GAAG,yBAAyB,CAAC,CAAC,EAChD,IAAI,CAAC;AACV;AAEO,eAAe,mBAAmB,KAAa;IACpD,IAAI;QACF,MAAM,SAAS;QACf,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM,IAAA,sKAAS,EAAC,OAAO;QAE3C,MAAM,QAAQ,OAAO,QAAQ,KAAK,KAAK,WAAW,QAAQ,KAAK,GAAG;QAClE,MAAM,SAAS,QAAQ,MAAM,KAAK,UAAU,QAAQ,MAAM,KAAK,UAAU,QAAQ,MAAM,GAAG;QAC1F,MAAM,WAAW,OAAO,QAAQ,QAAQ,KAAK,WAAW,QAAQ,QAAQ,GAAG;QAC3E,MAAM,YAAY,OAAO,QAAQ,SAAS,KAAK,WAAW,QAAQ,SAAS,GAAG;QAC9E,MAAM,WAAW,OAAO,QAAQ,QAAQ,KAAK,WAAW,QAAQ,QAAQ,GAAG;QAC3E,MAAM,cAAc,OAAO,QAAQ,WAAW,KAAK,WAAW,QAAQ,WAAW,GAAG;QACpF,MAAM,OAAO,QAAQ,IAAI,KAAK,oBAAoB,QAAQ,IAAI,KAAK,YAAY,QAAQ,IAAI,GAAG;QAE9F,IAAI,CAAC,SAAS,CAAC,QAAQ;YACrB,OAAO;QACT;QAEA,OAAO;YAAE;YAAO;YAAQ;YAAU;YAAW;YAAU;YAAa;QAAK;IAC3E,EAAE,OAAM;QACN,OAAO;IACT;AACF;AAEO,SAAS;IACd,OAAO;AACT"}},
    {"offset": {"line": 137, "column": 0}, "map": {"version":3,"sources":["file:///home/alabrador/dashboard-ansible-ia/src/lib/auth/ldap-config-store.ts"],"sourcesContent":["import { promises as fs } from \"node:fs\";\nimport { join } from \"node:path\";\nimport { kv } from \"@vercel/kv\";\nimport type { UserRole } from \"@/lib/auth/types\";\n\nconst STORE_DIR = join(process.cwd(), \"uploads\");\nconst STORE_PATH = join(STORE_DIR, \"ldap-config.json\");\nconst KV_LDAP_CONFIG_KEY = \"dashboard:ldap-config\";\n\nexport type StoredLdapConfig = {\n  url: string;\n  baseDn: string;\n  userFilter: string;\n  bindDn?: string;\n  bindPassword?: string;\n  timeoutMs: number;\n  adminEmails: string[];\n};\n\ntype RawStoredLdapConfig = {\n  url?: string;\n  baseDn?: string;\n  userFilter?: string;\n  bindDn?: string;\n  bindPassword?: string;\n  timeoutMs?: number;\n  adminEmails?: string[];\n};\n\nfunction isVercelKvConfigured(): boolean {\n  return Boolean(process.env.KV_REST_API_URL && process.env.KV_REST_API_TOKEN);\n}\n\nfunction normalizeEmailList(values: string[]): string[] {\n  return values\n    .map((value) => value.trim().toLowerCase())\n    .filter(Boolean);\n}\n\nfunction normalizeConfig(config: RawStoredLdapConfig | null | undefined): StoredLdapConfig | null {\n  if (!config) {\n    return null;\n  }\n\n  const url = typeof config.url === \"string\" ? config.url.trim() : \"\";\n  const baseDn = typeof config.baseDn === \"string\" ? config.baseDn.trim() : \"\";\n\n  if (!url || !baseDn) {\n    return null;\n  }\n\n  const userFilter =\n    typeof config.userFilter === \"string\" && config.userFilter.trim()\n      ? config.userFilter.trim()\n      : \"(mail={{email}})\";\n\n  const bindDn = typeof config.bindDn === \"string\" && config.bindDn.trim() ? config.bindDn.trim() : undefined;\n  const bindPassword =\n    typeof config.bindPassword === \"string\" && config.bindPassword.trim()\n      ? config.bindPassword\n      : undefined;\n\n  const timeoutCandidate =\n    typeof config.timeoutMs === \"number\" && Number.isFinite(config.timeoutMs) ? config.timeoutMs : 5000;\n  const timeoutMs = Math.max(1000, Math.min(20000, Math.floor(timeoutCandidate)));\n\n  const adminEmails = Array.isArray(config.adminEmails)\n    ? normalizeEmailList(config.adminEmails)\n    : [];\n\n  return {\n    url,\n    baseDn,\n    userFilter,\n    bindDn,\n    bindPassword,\n    timeoutMs,\n    adminEmails,\n  };\n}\n\nasync function ensureStoreFile(): Promise<void> {\n  await fs.mkdir(STORE_DIR, { recursive: true });\n\n  try {\n    await fs.access(STORE_PATH);\n  } catch {\n    await fs.writeFile(STORE_PATH, JSON.stringify({}, null, 2), \"utf8\");\n  }\n}\n\nexport async function readStoredLdapConfig(): Promise<StoredLdapConfig | null> {\n  if (isVercelKvConfigured()) {\n    const payload = await kv.get<RawStoredLdapConfig>(KV_LDAP_CONFIG_KEY);\n    return normalizeConfig(payload);\n  }\n\n  await ensureStoreFile();\n  const raw = await fs.readFile(STORE_PATH, \"utf8\");\n\n  try {\n    const parsed = JSON.parse(raw) as RawStoredLdapConfig;\n    return normalizeConfig(parsed);\n  } catch {\n    return null;\n  }\n}\n\nexport async function writeStoredLdapConfig(config: StoredLdapConfig): Promise<void> {\n  const normalized = normalizeConfig(config);\n  if (!normalized) {\n    throw new Error(\"Configuración LDAP inválida.\");\n  }\n\n  if (isVercelKvConfigured()) {\n    await kv.set(KV_LDAP_CONFIG_KEY, normalized);\n    return;\n  }\n\n  await ensureStoreFile();\n  await fs.writeFile(STORE_PATH, JSON.stringify(normalized, null, 2), \"utf8\");\n}\n\nexport async function buildLdapAdminRole(email: string): Promise<UserRole> {\n  const normalizedEmail = email.trim().toLowerCase();\n  const config = await readStoredLdapConfig();\n\n  if (!config) {\n    return \"tecnico\";\n  }\n\n  return config.adminEmails.includes(normalizedEmail) ? \"administrativo\" : \"tecnico\";\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AACA;;;;AAGA,MAAM,YAAY,IAAA,yHAAI,EAAC,QAAQ,GAAG,IAAI;AACtC,MAAM,aAAa,IAAA,yHAAI,EAAC,WAAW;AACnC,MAAM,qBAAqB;AAsB3B,SAAS;IACP,OAAO,QAAQ,QAAQ,GAAG,CAAC,eAAe,IAAI,QAAQ,GAAG,CAAC,iBAAiB;AAC7E;AAEA,SAAS,mBAAmB,MAAgB;IAC1C,OAAO,OACJ,GAAG,CAAC,CAAC,QAAU,MAAM,IAAI,GAAG,WAAW,IACvC,MAAM,CAAC;AACZ;AAEA,SAAS,gBAAgB,MAA8C;IACrE,IAAI,CAAC,QAAQ;QACX,OAAO;IACT;IAEA,MAAM,MAAM,OAAO,OAAO,GAAG,KAAK,WAAW,OAAO,GAAG,CAAC,IAAI,KAAK;IACjE,MAAM,SAAS,OAAO,OAAO,MAAM,KAAK,WAAW,OAAO,MAAM,CAAC,IAAI,KAAK;IAE1E,IAAI,CAAC,OAAO,CAAC,QAAQ;QACnB,OAAO;IACT;IAEA,MAAM,aACJ,OAAO,OAAO,UAAU,KAAK,YAAY,OAAO,UAAU,CAAC,IAAI,KAC3D,OAAO,UAAU,CAAC,IAAI,KACtB;IAEN,MAAM,SAAS,OAAO,OAAO,MAAM,KAAK,YAAY,OAAO,MAAM,CAAC,IAAI,KAAK,OAAO,MAAM,CAAC,IAAI,KAAK;IAClG,MAAM,eACJ,OAAO,OAAO,YAAY,KAAK,YAAY,OAAO,YAAY,CAAC,IAAI,KAC/D,OAAO,YAAY,GACnB;IAEN,MAAM,mBACJ,OAAO,OAAO,SAAS,KAAK,YAAY,OAAO,QAAQ,CAAC,OAAO,SAAS,IAAI,OAAO,SAAS,GAAG;IACjG,MAAM,YAAY,KAAK,GAAG,CAAC,MAAM,KAAK,GAAG,CAAC,OAAO,KAAK,KAAK,CAAC;IAE5D,MAAM,cAAc,MAAM,OAAO,CAAC,OAAO,WAAW,IAChD,mBAAmB,OAAO,WAAW,IACrC,EAAE;IAEN,OAAO;QACL;QACA;QACA;QACA;QACA;QACA;QACA;IACF;AACF;AAEA,eAAe;IACb,MAAM,yHAAE,CAAC,KAAK,CAAC,WAAW;QAAE,WAAW;IAAK;IAE5C,IAAI;QACF,MAAM,yHAAE,CAAC,MAAM,CAAC;IAClB,EAAE,OAAM;QACN,MAAM,yHAAE,CAAC,SAAS,CAAC,YAAY,KAAK,SAAS,CAAC,CAAC,GAAG,MAAM,IAAI;IAC9D;AACF;AAEO,eAAe;IACpB,IAAI,wBAAwB;QAC1B,MAAM,UAAU,MAAM,uJAAE,CAAC,GAAG,CAAsB;QAClD,OAAO,gBAAgB;IACzB;IAEA,MAAM;IACN,MAAM,MAAM,MAAM,yHAAE,CAAC,QAAQ,CAAC,YAAY;IAE1C,IAAI;QACF,MAAM,SAAS,KAAK,KAAK,CAAC;QAC1B,OAAO,gBAAgB;IACzB,EAAE,OAAM;QACN,OAAO;IACT;AACF;AAEO,eAAe,sBAAsB,MAAwB;IAClE,MAAM,aAAa,gBAAgB;IACnC,IAAI,CAAC,YAAY;QACf,MAAM,IAAI,MAAM;IAClB;IAEA,IAAI,wBAAwB;QAC1B,MAAM,uJAAE,CAAC,GAAG,CAAC,oBAAoB;QACjC;IACF;IAEA,MAAM;IACN,MAAM,yHAAE,CAAC,SAAS,CAAC,YAAY,KAAK,SAAS,CAAC,YAAY,MAAM,IAAI;AACtE;AAEO,eAAe,mBAAmB,KAAa;IACpD,MAAM,kBAAkB,MAAM,IAAI,GAAG,WAAW;IAChD,MAAM,SAAS,MAAM;IAErB,IAAI,CAAC,QAAQ;QACX,OAAO;IACT;IAEA,OAAO,OAAO,WAAW,CAAC,QAAQ,CAAC,mBAAmB,mBAAmB;AAC3E"}},
    {"offset": {"line": 233, "column": 0}, "map": {"version":3,"sources":["file:///home/alabrador/dashboard-ansible-ia/src/app/api/auth/ldap-config/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\nimport { cookies } from \"next/headers\";\nimport { getSessionCookieName, verifySessionToken } from \"@/lib/auth/session\";\nimport { readStoredLdapConfig, writeStoredLdapConfig, type StoredLdapConfig } from \"@/lib/auth/ldap-config-store\";\n\ntype LdapConfigBody = {\n  url?: string;\n  baseDn?: string;\n  userFilter?: string;\n  bindDn?: string;\n  bindPassword?: string;\n  timeoutMs?: number;\n  adminEmails?: string;\n};\n\nconst NO_CACHE_HEADERS: HeadersInit = {\n  \"Cache-Control\": \"private, no-store, no-cache, must-revalidate, max-age=0\",\n  Pragma: \"no-cache\",\n  Expires: \"0\",\n  Vary: \"Cookie\",\n};\n\nasync function requireAdminSession(): Promise<NextResponse | null> {\n  const cookieStore = await cookies();\n  const token = cookieStore.get(getSessionCookieName())?.value;\n\n  if (!token) {\n    return NextResponse.json({ error: \"No autenticado.\" }, { status: 401, headers: NO_CACHE_HEADERS });\n  }\n\n  const session = await verifySessionToken(token);\n  if (!session) {\n    return NextResponse.json({ error: \"Sesión inválida.\" }, { status: 401, headers: NO_CACHE_HEADERS });\n  }\n\n  if (session.role !== \"administrativo\") {\n    return NextResponse.json({ error: \"No autorizado.\" }, { status: 403, headers: NO_CACHE_HEADERS });\n  }\n\n  return null;\n}\n\nfunction normalizeAdminEmails(value?: string): string[] {\n  return (value ?? \"\")\n    .split(\";\")\n    .map((item) => item.trim().toLowerCase())\n    .filter(Boolean);\n}\n\nfunction parseConfig(body: LdapConfigBody): StoredLdapConfig {\n  const timeoutCandidate = typeof body.timeoutMs === \"number\" ? body.timeoutMs : Number(body.timeoutMs ?? 5000);\n\n  return {\n    url: body.url?.trim() ?? \"\",\n    baseDn: body.baseDn?.trim() ?? \"\",\n    userFilter: body.userFilter?.trim() || \"(mail={{email}})\",\n    bindDn: body.bindDn?.trim() || undefined,\n    bindPassword: body.bindPassword?.trim() || undefined,\n    timeoutMs: Number.isFinite(timeoutCandidate) ? Math.max(1000, Math.min(20000, Math.floor(timeoutCandidate))) : 5000,\n    adminEmails: normalizeAdminEmails(body.adminEmails),\n  };\n}\n\nfunction validateConfig(config: StoredLdapConfig): string | null {\n  if (!config.url || !config.baseDn) {\n    return \"Debes completar URL de LDAP y Base DN.\";\n  }\n\n  return null;\n}\n\nexport async function GET() {\n  const unauthorized = await requireAdminSession();\n  if (unauthorized) {\n    return unauthorized;\n  }\n\n  try {\n    const config = await readStoredLdapConfig();\n\n    return NextResponse.json(\n      {\n        config: config\n          ? {\n              url: config.url,\n              baseDn: config.baseDn,\n              userFilter: config.userFilter,\n              bindDn: config.bindDn ?? \"\",\n              bindPassword: config.bindPassword ?? \"\",\n              timeoutMs: config.timeoutMs,\n              adminEmails: config.adminEmails.join(\";\"),\n            }\n          : null,\n      },\n      { headers: NO_CACHE_HEADERS },\n    );\n  } catch {\n    return NextResponse.json(\n      { error: \"No se pudo cargar la configuración LDAP.\" },\n      { status: 500, headers: NO_CACHE_HEADERS },\n    );\n  }\n}\n\nexport async function PUT(request: Request) {\n  const unauthorized = await requireAdminSession();\n  if (unauthorized) {\n    return unauthorized;\n  }\n\n  try {\n    const body = (await request.json()) as LdapConfigBody;\n    const config = parseConfig(body);\n    const validationError = validateConfig(config);\n\n    if (validationError) {\n      return NextResponse.json({ error: validationError }, { status: 400, headers: NO_CACHE_HEADERS });\n    }\n\n    await writeStoredLdapConfig(config);\n    return NextResponse.json({ ok: true }, { headers: NO_CACHE_HEADERS });\n  } catch {\n    return NextResponse.json(\n      { error: \"No se pudo guardar la configuración LDAP.\" },\n      { status: 500, headers: NO_CACHE_HEADERS },\n    );\n  }\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;;;;;AAYA,MAAM,mBAAgC;IACpC,iBAAiB;IACjB,QAAQ;IACR,SAAS;IACT,MAAM;AACR;AAEA,eAAe;IACb,MAAM,cAAc,MAAM,IAAA,4IAAO;IACjC,MAAM,QAAQ,YAAY,GAAG,CAAC,IAAA,uJAAoB,MAAK;IAEvD,IAAI,CAAC,OAAO;QACV,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAkB,GAAG;YAAE,QAAQ;YAAK,SAAS;QAAiB;IAClG;IAEA,MAAM,UAAU,MAAM,IAAA,qJAAkB,EAAC;IACzC,IAAI,CAAC,SAAS;QACZ,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAmB,GAAG;YAAE,QAAQ;YAAK,SAAS;QAAiB;IACnG;IAEA,IAAI,QAAQ,IAAI,KAAK,kBAAkB;QACrC,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAiB,GAAG;YAAE,QAAQ;YAAK,SAAS;QAAiB;IACjG;IAEA,OAAO;AACT;AAEA,SAAS,qBAAqB,KAAc;IAC1C,OAAO,CAAC,SAAS,EAAE,EAChB,KAAK,CAAC,KACN,GAAG,CAAC,CAAC,OAAS,KAAK,IAAI,GAAG,WAAW,IACrC,MAAM,CAAC;AACZ;AAEA,SAAS,YAAY,IAAoB;IACvC,MAAM,mBAAmB,OAAO,KAAK,SAAS,KAAK,WAAW,KAAK,SAAS,GAAG,OAAO,KAAK,SAAS,IAAI;IAExG,OAAO;QACL,KAAK,KAAK,GAAG,EAAE,UAAU;QACzB,QAAQ,KAAK,MAAM,EAAE,UAAU;QAC/B,YAAY,KAAK,UAAU,EAAE,UAAU;QACvC,QAAQ,KAAK,MAAM,EAAE,UAAU;QAC/B,cAAc,KAAK,YAAY,EAAE,UAAU;QAC3C,WAAW,OAAO,QAAQ,CAAC,oBAAoB,KAAK,GAAG,CAAC,MAAM,KAAK,GAAG,CAAC,OAAO,KAAK,KAAK,CAAC,sBAAsB;QAC/G,aAAa,qBAAqB,KAAK,WAAW;IACpD;AACF;AAEA,SAAS,eAAe,MAAwB;IAC9C,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,MAAM,EAAE;QACjC,OAAO;IACT;IAEA,OAAO;AACT;AAEO,eAAe;IACpB,MAAM,eAAe,MAAM;IAC3B,IAAI,cAAc;QAChB,OAAO;IACT;IAEA,IAAI;QACF,MAAM,SAAS,MAAM,IAAA,uKAAoB;QAEzC,OAAO,gJAAY,CAAC,IAAI,CACtB;YACE,QAAQ,SACJ;gBACE,KAAK,OAAO,GAAG;gBACf,QAAQ,OAAO,MAAM;gBACrB,YAAY,OAAO,UAAU;gBAC7B,QAAQ,OAAO,MAAM,IAAI;gBACzB,cAAc,OAAO,YAAY,IAAI;gBACrC,WAAW,OAAO,SAAS;gBAC3B,aAAa,OAAO,WAAW,CAAC,IAAI,CAAC;YACvC,IACA;QACN,GACA;YAAE,SAAS;QAAiB;IAEhC,EAAE,OAAM;QACN,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAA2C,GACpD;YAAE,QAAQ;YAAK,SAAS;QAAiB;IAE7C;AACF;AAEO,eAAe,IAAI,OAAgB;IACxC,MAAM,eAAe,MAAM;IAC3B,IAAI,cAAc;QAChB,OAAO;IACT;IAEA,IAAI;QACF,MAAM,OAAQ,MAAM,QAAQ,IAAI;QAChC,MAAM,SAAS,YAAY;QAC3B,MAAM,kBAAkB,eAAe;QAEvC,IAAI,iBAAiB;YACnB,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAgB,GAAG;gBAAE,QAAQ;gBAAK,SAAS;YAAiB;QAChG;QAEA,MAAM,IAAA,wKAAqB,EAAC;QAC5B,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,IAAI;QAAK,GAAG;YAAE,SAAS;QAAiB;IACrE,EAAE,OAAM;QACN,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAA4C,GACrD;YAAE,QAAQ;YAAK,SAAS;QAAiB;IAE7C;AACF"}}]
}